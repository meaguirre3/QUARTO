{"title":"Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)","markdown":{"yaml":{"title":"Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)","author":"Marco Aguirre","date":"2023-08-6","categories":["news","code","algorithms","Python"],"image":"portada.png","bibliography":"bibliography.bib","format":{"html":{"toc":true,"code-tools":true}},"jupyter":"python3"},"headingText":"1. Objectives","containsRefs":false,"markdown":"\n\n\n- Implement the BFS (Breadth-First Search) and DFS (Depth-First Search) algorithms in Python.\n- Verify that BFS calculates the path with the fewest edges between two vertices of the graph.\n- Verify that DFS allows finding all vertices accessible from a source vertex of the graph.\n\n## 2. Introduction\n\nBFS is a way to find all vertices accessible from a source vertex of a graph. The search resembles a wave that hits all vertices starting from node 1 (beginning). The FIFO queue Q is used to maintain the wavefront, and control is kept over nodes already included in the wave to prevent them from being revisited. BFS allows obtaining the shortest path from the source node to the other connected nodes. The efficiency of BFS is O(number of vertices + number of edges), commonly written as O(V + E) (V for the number of vertices, E for the number of edges). BFS is used to solve the following problems:\n\n- Testing if a graph is connected.\n- Calculating the spanning forest of the graph.\n- Calculating for each vertex in the graph, a path with the minimum number of edges between the initial vertex and the current vertex or informing that no such path exists.\n\nDFS (Depth-First Search) is a systematic way of finding all vertices accessible from a source vertex. Like breadth-first search, DFS traverses a connected component of a given graph and defines a spanning tree. The basic idea of depth-first search is the following: it systematically explores each edge. We start over from different vertices as needed. As soon as we discover a vertex, DFS starts exploring from it (unlike BFS, which places a vertex in a queue to explore later), only backtracking when necessary [@muniswamy2013design]. DFS is used to solve the following problems:\n\n- Testing if the graph is connected.\n- Calculating the spanning forest of the graph.\n- Calculating a path between two vertices of the graph or informing that no such path exists.\n- Calculating a cycle in the graph or informing that no such cycle exists.\n\n\n## 3. Exercise 1\n\n### A. Problem Statement\n\nImplement the BFS algorithm to answer the following questions:\n1. Is there a path from CAB to BAT?\n2. What is that path?\n\n\n```{mermaid}\ngraph TD\n    CAB  --> CAT \n    CAB  --> CAR\n    CAR --> CAT\n    CAR --> BAR\n    CAT --> MAT\n    CAT --> BAT\n    MAT --> BAT\n    BAR --> MAT\n\n```\n\n### B. Implementation in Python\n\nTo implement the BFS algorithm in Python, a queue is used to enqueue the neighbor nodes of each source node. In the BFS function, two dictionaries are created: one called `marked` to mark nodes that have already been enqueued, and `edgeto` to assign each node its preceding node.\n\n\n### C. Execution of the Algorithm\n\n- The graph is constructed using a Python dictionary where the key is the node, and the value is a list of the node's neighbors. Note that the graph to be analyzed (Illustration) is directed, so only the target neighbors should be included.\n\n\n```{mermaid}\ngraph TD\n    CAB --> CAT\n    CAT --> BAT\n\n```\n\n```{mermaid}\ngraph TD\n    CAB --> CAT\n    CAB --> CAR\n    CAT --> MAT\n    CAT --> BAT\n    CAR --> BAR\n```\n\n## 4. Exercise 2\n\n### D. Problem Statement\n\nWhat are the DFS Trees for the following graph G, given that the starting node is 0? Implement the DFS algorithm (using the recursive method) and use the necessary auxiliary structures.\n\n\n```{mermaid}\ngraph TD\n    0 <--> 2\n    0 <--> 1\n    0 <--> 5\n    1 <--> 2\n    2 <--> 3\n    2 <--> 4\n    3 <--> 5\n    3 <--> 4\n    6 <--> 7\n\n```\n\n### Execution of the Algorithm\n\n- Define the graph and the starting node 0 as input parameters.\n\n- The execution of DFS provides the complete `edgeto` structure, which allows generating the route tree of the connected component, the DFS Tree.\n\n\n\n- To obtain all the routes, the `route` function  was executed with the `edgeto` obtained for each node, storing this result in the `routes` dictionary, which allows knowing the route from the origin to each node.\n\n\n```{mermaid}\ngraph TD\n 0 --> 2\n 2 --> 1\n 2 --> 3\n 3 --> 4\n 3 --> 5\n```\n","srcMarkdownNoYaml":"\n\n## 1. Objectives\n\n- Implement the BFS (Breadth-First Search) and DFS (Depth-First Search) algorithms in Python.\n- Verify that BFS calculates the path with the fewest edges between two vertices of the graph.\n- Verify that DFS allows finding all vertices accessible from a source vertex of the graph.\n\n## 2. Introduction\n\nBFS is a way to find all vertices accessible from a source vertex of a graph. The search resembles a wave that hits all vertices starting from node 1 (beginning). The FIFO queue Q is used to maintain the wavefront, and control is kept over nodes already included in the wave to prevent them from being revisited. BFS allows obtaining the shortest path from the source node to the other connected nodes. The efficiency of BFS is O(number of vertices + number of edges), commonly written as O(V + E) (V for the number of vertices, E for the number of edges). BFS is used to solve the following problems:\n\n- Testing if a graph is connected.\n- Calculating the spanning forest of the graph.\n- Calculating for each vertex in the graph, a path with the minimum number of edges between the initial vertex and the current vertex or informing that no such path exists.\n\nDFS (Depth-First Search) is a systematic way of finding all vertices accessible from a source vertex. Like breadth-first search, DFS traverses a connected component of a given graph and defines a spanning tree. The basic idea of depth-first search is the following: it systematically explores each edge. We start over from different vertices as needed. As soon as we discover a vertex, DFS starts exploring from it (unlike BFS, which places a vertex in a queue to explore later), only backtracking when necessary [@muniswamy2013design]. DFS is used to solve the following problems:\n\n- Testing if the graph is connected.\n- Calculating the spanning forest of the graph.\n- Calculating a path between two vertices of the graph or informing that no such path exists.\n- Calculating a cycle in the graph or informing that no such cycle exists.\n\n\n## 3. Exercise 1\n\n### A. Problem Statement\n\nImplement the BFS algorithm to answer the following questions:\n1. Is there a path from CAB to BAT?\n2. What is that path?\n\n\n```{mermaid}\ngraph TD\n    CAB  --> CAT \n    CAB  --> CAR\n    CAR --> CAT\n    CAR --> BAR\n    CAT --> MAT\n    CAT --> BAT\n    MAT --> BAT\n    BAR --> MAT\n\n```\n\n### B. Implementation in Python\n\nTo implement the BFS algorithm in Python, a queue is used to enqueue the neighbor nodes of each source node. In the BFS function, two dictionaries are created: one called `marked` to mark nodes that have already been enqueued, and `edgeto` to assign each node its preceding node.\n\n\n### C. Execution of the Algorithm\n\n- The graph is constructed using a Python dictionary where the key is the node, and the value is a list of the node's neighbors. Note that the graph to be analyzed (Illustration) is directed, so only the target neighbors should be included.\n\n\n```{mermaid}\ngraph TD\n    CAB --> CAT\n    CAT --> BAT\n\n```\n\n```{mermaid}\ngraph TD\n    CAB --> CAT\n    CAB --> CAR\n    CAT --> MAT\n    CAT --> BAT\n    CAR --> BAR\n```\n\n## 4. Exercise 2\n\n### D. Problem Statement\n\nWhat are the DFS Trees for the following graph G, given that the starting node is 0? Implement the DFS algorithm (using the recursive method) and use the necessary auxiliary structures.\n\n\n```{mermaid}\ngraph TD\n    0 <--> 2\n    0 <--> 1\n    0 <--> 5\n    1 <--> 2\n    2 <--> 3\n    2 <--> 4\n    3 <--> 5\n    3 <--> 4\n    6 <--> 7\n\n```\n\n### Execution of the Algorithm\n\n- Define the graph and the starting node 0 as input parameters.\n\n- The execution of DFS provides the complete `edgeto` structure, which allows generating the route tree of the connected component, the DFS Tree.\n\n\n\n- To obtain all the routes, the `route` function  was executed with the `edgeto` obtained for each node, storing this result in the `routes` dictionary, which allows knowing the route from the origin to each node.\n\n\n```{mermaid}\ngraph TD\n 0 --> 2\n 2 --> 1\n 2 --> 3\n 3 --> 4\n 3 --> 5\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"BFS.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","theme":"cosmo","title-block-banner":true,"title":"Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)","author":"Marco Aguirre","date":"2023-08-6","categories":["news","code","algorithms","Python"],"image":"portada.png","bibliography":["bibliography.bib"],"jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}