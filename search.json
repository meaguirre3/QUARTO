[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Marco Aguirre",
    "section": "",
    "text": "Master of Computer Science with a focus on Intelligent Systems, seeking to provide support and solutions to optimize processes and make data-driven decisions. Passionate about problem-solving and innovation through data science."
  },
  {
    "objectID": "about.html#professional-summary",
    "href": "about.html#professional-summary",
    "title": "Marco Aguirre",
    "section": "",
    "text": "Master of Computer Science with a focus on Intelligent Systems, seeking to provide support and solutions to optimize processes and make data-driven decisions. Passionate about problem-solving and innovation through data science."
  },
  {
    "objectID": "about.html#professional-objective",
    "href": "about.html#professional-objective",
    "title": "Marco Aguirre",
    "section": "Professional Objective",
    "text": "Professional Objective\nTo apply my experience in Data Analysis, Machine Learning, Information Technology, and software development to solve complex problems and provide data-driven solutions that drive informed decision-making within an organization. Committed to the continuous pursuit of excellence in data science, exploring new techniques, and innovatively using technology to address business challenges."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Marco Aguirre",
    "section": "Education",
    "text": "Education\n\nMaster of Computer Science with a focus on Intelligent Systems | National Polytechnic School | Quito, Ecuador | 2021 - 2023|\nElectronics and Telecommunications Engineering |Armed Forces University - ESPE | Sangolqui, Ecuador | 2012 - 2018"
  },
  {
    "objectID": "about.html#professional-experience",
    "href": "about.html#professional-experience",
    "title": "Marco Aguirre",
    "section": "Professional Experience",
    "text": "Professional Experience\n\nResearch Technician | National Polytechnic School | 2021 - 2023 | Management and analysis of research with data and its collection, cleaning, analysis, preprocessing, and modeling. Development of Data Mining projects.\nTechnical Support | FIXGROUP | 2019 - 2021 | Management of wireless links, design of hotspots, and managed Wi-Fi through Aruba.\nResearch Assistant | Armed Forces University ESPE | 2017 - 2018 | Management of wireless networks and exploration of new wireless communication technologies."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Marco Aguirre",
    "section": "",
    "text": "Strava Information Plot pydeck\n\n\n\n\n\n\n\ncode\n\n\nalgorithms\n\n\nPython\n\n\nStrava\n\n\n\n\n\n\n\n\n\n\n\nMay 27, 2024\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMay 14, 2024\n\n\nMarco Esteban Aguirre Rojas\n\n\n\n\n\n\n  \n\n\n\n\nAlgorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nalgorithms\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nStrava GPX Plotter: Mapping Beautiful Journeys with Folium in Python\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nvisualization\n\n\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nStrava Route Plot OSMNX\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nvisualization\n\n\n\n\n\n\n\n\n\n\n\nMar 17, 2022\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nStable Matching\n\n\n\n\n\n\n\ncode\n\n\nalgorithms\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\n\nJan 12, 2022\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nSelection Sort\n\n\n\n\n\n\n\ncode\n\n\nalgorithms\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nDec 23, 2021\n\n\nMarco Aguirre\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notebooks.html",
    "href": "notebooks.html",
    "title": "Notebooks",
    "section": "",
    "text": "Strava Information Plot pydeck\n\n\n\n\n\n\n\ncode\n\n\nalgorithms\n\n\nPython\n\n\nStrava\n\n\n\n\n\n\n\n\n\n\n\nMay 27, 2024\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMay 14, 2024\n\n\nMarco Esteban Aguirre Rojas\n\n\n\n\n\n\n  \n\n\n\n\nAlgorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nalgorithms\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nStrava GPX Plotter: Mapping Beautiful Journeys with Folium in Python\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nvisualization\n\n\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nStrava Route Plot OSMNX\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nvisualization\n\n\n\n\n\n\n\n\n\n\n\nMar 17, 2022\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nStable Matching\n\n\n\n\n\n\n\ncode\n\n\nalgorithms\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\n\nJan 12, 2022\n\n\nMarco Aguirre\n\n\n\n\n\n\n  \n\n\n\n\nSelection Sort\n\n\n\n\n\n\n\ncode\n\n\nalgorithms\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nDec 23, 2021\n\n\nMarco Aguirre\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html",
    "href": "posts/BFS_DFS/BFS.html",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "",
    "text": "Implement the BFS (Breadth-First Search) and DFS (Depth-First Search) algorithms in Python.\nVerify that BFS calculates the path with the fewest edges between two vertices of the graph.\nVerify that DFS allows finding all vertices accessible from a source vertex of the graph."
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#objectives",
    "href": "posts/BFS_DFS/BFS.html#objectives",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "",
    "text": "Implement the BFS (Breadth-First Search) and DFS (Depth-First Search) algorithms in Python.\nVerify that BFS calculates the path with the fewest edges between two vertices of the graph.\nVerify that DFS allows finding all vertices accessible from a source vertex of the graph."
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#introduction",
    "href": "posts/BFS_DFS/BFS.html#introduction",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "2. Introduction",
    "text": "2. Introduction\nBFS is a way to find all vertices accessible from a source vertex of a graph. The search resembles a wave that hits all vertices starting from node 1 (beginning). The FIFO queue Q is used to maintain the wavefront, and control is kept over nodes already included in the wave to prevent them from being revisited. BFS allows obtaining the shortest path from the source node to the other connected nodes. The efficiency of BFS is O(number of vertices + number of edges), commonly written as O(V + E) (V for the number of vertices, E for the number of edges). BFS is used to solve the following problems:\n\nTesting if a graph is connected.\nCalculating the spanning forest of the graph.\nCalculating for each vertex in the graph, a path with the minimum number of edges between the initial vertex and the current vertex or informing that no such path exists.\n\nDFS (Depth-First Search) is a systematic way of finding all vertices accessible from a source vertex. Like breadth-first search, DFS traverses a connected component of a given graph and defines a spanning tree. The basic idea of depth-first search is the following: it systematically explores each edge. We start over from different vertices as needed. As soon as we discover a vertex, DFS starts exploring from it (unlike BFS, which places a vertex in a queue to explore later), only backtracking when necessary (Muniswamy 2013). DFS is used to solve the following problems:\n\nTesting if the graph is connected.\nCalculating the spanning forest of the graph.\nCalculating a path between two vertices of the graph or informing that no such path exists.\nCalculating a cycle in the graph or informing that no such cycle exists."
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#exercise-1",
    "href": "posts/BFS_DFS/BFS.html#exercise-1",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "3. Exercise 1",
    "text": "3. Exercise 1\n\nA. Problem Statement\nImplement the BFS algorithm to answer the following questions: 1. Is there a path from CAB to BAT? 2. What is that path?\n\n\n\n\ngraph TD\n    CAB  --&gt; CAT \n    CAB  --&gt; CAR\n    CAR --&gt; CAT\n    CAR --&gt; BAR\n    CAT --&gt; MAT\n    CAT --&gt; BAT\n    MAT --&gt; BAT\n    BAR --&gt; MAT\n\n\n\n\n\n\n\n\nB. Implementation in Python\nTo implement the BFS algorithm in Python, a queue is used to enqueue the neighbor nodes of each source node. In the BFS function, two dictionaries are created: one called marked to mark nodes that have already been enqueued, and edgeto to assign each node its preceding node.\n\nfrom collections import deque\n\ndef busqueda_BFS(name,graph):\n    \"\"\"\n    busqueda_BFS Search Algorithm\n\n    Args:\n        start (str): The starting node.\n        graph (dict): The graph represented as an adjacency list.\n\n    Returns:\n        edgeto (dict): A dictionary containing the parent nodes of the connected component.\n    \"\"\"\n    ##############ESTRUCTURAS AUXILIARES \n    marked= dict.fromkeys(graph.keys(),False)\n    marked[name]=True\n    edgeto={name:\"inicio\"}\n    edgeto.update(dict.fromkeys(graph[name],name))\n    marked.update(dict.fromkeys(graph[name],True))\n    ##############ESTRUCTURAS AUXILIARES \n    search_queue = deque()\n    search_queue += graph[name] \n    searched = [] \n    while search_queue:\n        person = search_queue.popleft() \n        if not person in searched: \n            comprueba=[ nodo  for nodo in graph[person] if marked[nodo]==False ]\n            edgeto.update(dict.fromkeys(comprueba,person))\n            marked.update(dict.fromkeys(comprueba,True))\n            search_queue += graph[person] \n            searched.append(person)\n    return edgeto\n\ndef ruta(busqueda,edgeto):\n    \"\"\" Retorna ruta del componente conectado nodo inico\n        Args:\n            edgeto :(dict) diccionario que estan los nodos padres del componete conectado\n            busqueda :(str) nodo buscar\n        return:\n            ruta list() : lista que contiene la ruta\n    \"\"\"\n    ruta=[]\n    if (busqueda in edgeto.keys()):\n        while busqueda !=\"inicio\":\n            ruta.insert(0,busqueda)\n            busqueda=edgeto[busqueda]   \n    return ruta\n\n\n\nC. Execution of the Algorithm\n\nThe graph is constructed using a Python dictionary where the key is the node, and the value is a list of the node’s neighbors. Note that the graph to be analyzed (Illustration) is directed, so only the target neighbors should be included.\n\n\ngraph = {}\ngraph[\"CAB\"] = [\"CAT\", \"CAR\"]\ngraph[\"CAR\"] = [\"CAT\", \"BAR\"]\ngraph[\"CAT\"] = [\"MAT\",\"BAT\"]\ngraph[\"MAT\"] = [\"BAT\"]\ngraph[\"BAR\"] = [\"MAT\"]\ngraph[\"BAT\"] = []\n\n\nedgeto=busqueda_BFS(\"CAB\",graph)\nedgeto\n\n{'CAB': 'inicio',\n 'CAT': 'CAB',\n 'CAR': 'CAB',\n 'MAT': 'CAT',\n 'BAT': 'CAT',\n 'BAR': 'CAR'}\n\n\n\nruta(\"BAT\",edgeto)\n\n['CAB', 'CAT', 'BAT']\n\n\n\n\n\n\ngraph TD\n    CAB --&gt; CAT\n    CAT --&gt; BAT\n\n\n\n\n\n\n\nrutas={nodo:ruta(nodo,edgeto) for nodo in edgeto.keys()}\nrutas\n\n{'CAB': ['CAB'],\n 'CAT': ['CAB', 'CAT'],\n 'CAR': ['CAB', 'CAR'],\n 'MAT': ['CAB', 'CAT', 'MAT'],\n 'BAT': ['CAB', 'CAT', 'BAT'],\n 'BAR': ['CAB', 'CAR', 'BAR']}\n\n\n\n\n\n\ngraph TD\n    CAB --&gt; CAT\n    CAB --&gt; CAR\n    CAT --&gt; MAT\n    CAT --&gt; BAT\n    CAR --&gt; BAR"
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#exercise-2",
    "href": "posts/BFS_DFS/BFS.html#exercise-2",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "4. Exercise 2",
    "text": "4. Exercise 2\n\nD. Problem Statement\nWhat are the DFS Trees for the following graph G, given that the starting node is 0? Implement the DFS algorithm (using the recursive method) and use the necessary auxiliary structures.\n\n\n\n\ngraph TD\n    0 &lt;--&gt; 2\n    0 &lt;--&gt; 1\n    0 &lt;--&gt; 5\n    1 &lt;--&gt; 2\n    2 &lt;--&gt; 3\n    2 &lt;--&gt; 4\n    3 &lt;--&gt; 5\n    3 &lt;--&gt; 4\n    6 &lt;--&gt; 7\n\n\n\n\n\n\n\ndef dfs( graph, node,visited=set()):\n    \"\"\"algortimo dfs\n        Args:\n            graph :(dict) diccionario que representa grafo\n            node :(str) nodo fuente o raiz\n            visited:control nodos visitados default set()\n        return:\n            ruta list() : lista que contiene la ruta\n    \"\"\"\n    if node not in visited: ##comparacion si el nodo no se ha visitad\n        print (node)##impresion de nodos visitados\n        visited.add(node) ##agregando nodos visitados\n        marked[node]=True##control de nodos visitados\n        for neighbour in graph[node]:\n            comprueba=[ nodo  for nodo in graph[node] if marked[nodo]==False ]##comprovacion\n            edgeto.update(dict.fromkeys(comprueba,node))##llenado de edgeto\n            dfs(graph, neighbour,visited)\n\n\ndef ruta_DFS(busqueda,edgeto):\n    \"\"\" Retorna ruta del componente conectado nodo inico\n        Args:\n            edgeto :(dict) diccionario que estan los nodos padres del componete conectado\n            busqueda :(str) nodo buscar\n        return:\n            ruta list() : lista que contiene la ruta\n    \"\"\"\n    ruta=[]\n    while busqueda !=\"\":\n        ruta.insert(0,busqueda)\n        busqueda=edgeto[busqueda]\n    return ruta\n\n\n\nExecution of the Algorithm\n\nDefine the graph and the starting node 0 as input parameters.\n\n\n#graph\ngraph = dict()\ngraph[\"0\"] = [\"2\", \"1\",\"5\"]\ngraph[\"1\"] = [\"0\", \"2\"]\ngraph[\"2\"] = [\"0\",\"1\",\"3\",\"4\"]\ngraph[\"3\"] = [\"5\",\"4\",\"2\"]\ngraph[\"4\"] = [\"3\",\"2\"]\ngraph[\"5\"] = [\"3\",\"0\"]\nmarked= dict.fromkeys(graph.keys(),False)\nedgeto= dict.fromkeys(graph.keys(),\"\")\n\n\nThe execution of DFS provides the complete edgeto structure, which allows generating the route tree of the connected component, the DFS Tree.\n\n\ndfs(graph,\"0\")\n\n0\n2\n1\n3\n5\n4\n\n\n\nTo obtain all the routes, the route function was executed with the edgeto obtained for each node, storing this result in the routes dictionary, which allows knowing the route from the origin to each node.\n\n\nedgeto\n\n{'0': '', '1': '2', '2': '0', '3': '2', '4': '3', '5': '3'}\n\n\n\nrutas={nodo:ruta_DFS(nodo,edgeto) for nodo in edgeto.keys()}\nrutas\n\n{'0': ['0'],\n '1': ['0', '2', '1'],\n '2': ['0', '2'],\n '3': ['0', '2', '3'],\n '4': ['0', '2', '3', '4'],\n '5': ['0', '2', '3', '5']}\n\n\n\n\n\n\ngraph TD\n 0 --&gt; 2\n 2 --&gt; 1\n 2 --&gt; 3\n 3 --&gt; 4\n 3 --&gt; 5"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html",
    "href": "posts/post-with-code/stravaPlotOSMNX.html",
    "title": "Strava Route Plot OSMNX",
    "section": "",
    "text": "Strava Route Plot using OSMnx involves visualizing and analyzing running or cycling routes recorded with the Strava app on maps generated with the OSMnx library. OSMnx is a Python package that allows users to download, model, and visualize street networks from OpenStreetMap’s data.\nimport osmnx as ox\nimport pandas as pd\nimport gpxpy\nimport gpxpy.gpx\nimport matplotlib.pyplot as plt\nimport polyline"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#read-route",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#read-route",
    "title": "Strava Route Plot OSMNX",
    "section": "1. Read Route",
    "text": "1. Read Route\n\npath = \"Princesa_Toa_.gpx\"\nwith open(path, 'r') as gpx_file:\n    gpx = gpxpy.parse(gpx_file)\n    \n# extract in gpx file latitude, longitude  and elevation\nroute_info = [{'latitude': point.latitude,'longitude': point.longitude,'elevation': point.elevation} \n              for track   in gpx.tracks  \n              for segment in track.segments \n              for point   in segment.points ]\n# route_df Dataframe\nroute_df = pd.DataFrame(route_info)\nroute_df.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\nelevation\n\n\n\n\n0\n-0.216083\n-78.436892\n2388.8\n\n\n1\n-0.216085\n-78.436895\n2388.8\n\n\n2\n-0.216141\n-78.436849\n2388.9\n\n\n3\n-0.216161\n-78.436832\n2388.9\n\n\n4\n-0.216211\n-78.436803\n2389.0"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#center-point-for-graph-in-ox",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#center-point-for-graph-in-ox",
    "title": "Strava Route Plot OSMNX",
    "section": "2. Center point for Graph in ox",
    "text": "2. Center point for Graph in ox\nLink osmnx graph_from_point fuction https://osmnx.readthedocs.io/en/stable/osmnx.html?highlight=graph_from_point#osmnx.graph.graph_from_point\n\n# center point to extract graph latitude , longitude\ncenter_point = (-0.26428048222240524, -78.4202862684383)\nG = ox.graph_from_point(center_point, dist=12000, retain_all=True, simplify = False, network_type='all')\n#bike all"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#plot-route",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#plot-route",
    "title": "Strava Route Plot OSMNX",
    "section": "3. Plot Route",
    "text": "3. Plot Route\n\nfig, ax = ox.plot_graph(G, node_size=0,\n                        figsize        = (11, 16), \n                        dpi            = 300,\n                        save           = False,\n                        bgcolor        = \"#FFFFFF\",\n                        edge_color     = \"#253951\",\n                        edge_alpha     = 0.2 ,\n                        show           = False)\n## Plot  activity in graph \nplt.plot( route_df['longitude'] , route_df['latitude'] ,\n         color     = \"#E64E25\" , \n         linewidth = 2.0)\n## Plot  activity in graph \nplt.show()\nfig.tight_layout(pad=0)\n## path name to save\npath_save = path.split(\".\")[0] + \".png\"\n# fig.savefig( path_save, dpi=300, format=\"png\", bbox_inches='tight',\n#             facecolor=fig.get_facecolor(), transparent=False)\n\n\n\n\n\n# save figure\nfig.savefig('activity.png')"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#plot-elevation",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#plot-elevation",
    "title": "Strava Route Plot OSMNX",
    "section": "4. Plot Elevation",
    "text": "4. Plot Elevation\n\nelevation = route_df.elevation\nx_plot    = range(len(elevation))\nmin_elev  = min(elevation) - 25\n\n\n# Set the figure size\nfig, ax = plt.subplots(figsize=(11, 2))\n# Area plot\nax.fill_between(x_plot, elevation, color=\"#E64E25\")\n# Set the minimum and maximum values for the y-axis\nax.set_ylim(min_elev, 4000)\nplt.axis('off')\n# Save the figure\npath_save = path.split(\".\")[0] +\"_elevation\" \".png\"\nplt.savefig(path_save , transparent=True, bbox_inches='tight', pad_inches=0 )\n# Display the plot\nplt.show()\n\n\n\n\n\nfig.savefig('perfil.png')"
  },
  {
    "objectID": "posts/SelectionSort/SelectionSort.html",
    "href": "posts/SelectionSort/SelectionSort.html",
    "title": "Selection Sort",
    "section": "",
    "text": "Implement the selection sort algorithm, analyze its performance and complexity in different scenarios.\nImplement a recursive function to familiarize ourselves with applying recursive algorithms or functions."
  },
  {
    "objectID": "posts/SelectionSort/SelectionSort.html#objectives",
    "href": "posts/SelectionSort/SelectionSort.html#objectives",
    "title": "Selection Sort",
    "section": "",
    "text": "Implement the selection sort algorithm, analyze its performance and complexity in different scenarios.\nImplement a recursive function to familiarize ourselves with applying recursive algorithms or functions."
  },
  {
    "objectID": "posts/SelectionSort/SelectionSort.html#introduction",
    "href": "posts/SelectionSort/SelectionSort.html#introduction",
    "title": "Selection Sort",
    "section": "Introduction",
    "text": "Introduction\nSorting a dataset involves arranging the data collection to establish an accurate relationship, in this case, order. Sorting is one of the most studied problems in computer science, resulting in many algorithms of varying efficiency that sort elements such as names, indices, letters, etc. (Necaise 2011). Selection sort is one of these sorting algorithms and is based on creating a new list where it places the values it is sorting. Its efficiency is $ O(n^{2}) $ .\nRecursion is a process for solving problems and a powerful programming tool to solve a larger problem by subdividing it into smaller cases, then solving the smaller problem to provide a solution to the initial problem. It can be used with a wide range of problems, from basic traditional iterations to more advanced backtracking problems. In some cases, recursion is not the efficient and elegant solution (Bhargava 2024)."
  },
  {
    "objectID": "posts/SelectionSort/SelectionSort.html#exercise-1",
    "href": "posts/SelectionSort/SelectionSort.html#exercise-1",
    "title": "Selection Sort",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nA. Problem Statement\nImplement the Selection Sort algorithm.\nThe Selection Sort algorithm consists of two functions. The first function, called findSmallest, is responsible for returning the index of the smallest element in the array. The second function is responsible for performing the sorting by placing the element from the index returned by the findSmallest function into a new array and removing this element from the original array. This process is repeated iteratively until all elements in the array are consumed.\n\ndef findSmallest(arreglo):\n    \"\"\"\n    funcion  que retorna el incice del valor mas pequeno del arregloeglo o lista\n    Inpust:\n        arreglo: arregloeglo de entrada\n    Returns:\n        indice_valor_mpequeno (int): indice del elemnto mas pequeno\n    \"\"\"\n    valor_mpequeno = arreglo[0] #tomamos el primer elemnto dl arreglo \n    indice_valor_mpequeno = 0 #se asgina indice 0\n    for i in range(1, len(arreglo)): #itermos para ir comparando\n        if arreglo[i] &lt; valor_mpequeno: #realizamos la comparacion elemnto a elemento\n            valor_mpequeno = arreglo[i]\n            indice_valor_mpequeno = i\n    return indice_valor_mpequeno #retornamos indice\n\n\ndef selectionSort(arreglo):\n    \"\"\"\n    Algoritmo de ordenamiento retorna el arregloeglo ordenado de menor a mayor\n  \n    Inpust:\n        arregloeglo: arregloeglo o lista a ordenar menor a mayor\n    Returns:\n        arregloeglo : ordenado \n    \"\"\"\n    nuevo_arreglo = [] #declaramos el arreglo a retornar \n    for i in range(len(arreglo)):#iteramos sobre al arreglo ingresado\n        indice_valor_mpqueno = findSmallest(arreglo)#obtenemo indice valor mas pequeno\n        nuevo_arreglo.append(arreglo.pop(indice_valor_mpqueno))\n    return nuevo_arreglo"
  },
  {
    "objectID": "posts/SelectionSort/SelectionSort.html#b.-execution-of-the-selection-sort-algorithm",
    "href": "posts/SelectionSort/SelectionSort.html#b.-execution-of-the-selection-sort-algorithm",
    "title": "Selection Sort",
    "section": "B. Execution of the Selection Sort Algorithm",
    "text": "B. Execution of the Selection Sort Algorithm\nTest the algorithm with the input of random integer data.\n\nimport random \n# list input shuffle\ninput_list = [ random.randint(1,100) for x in range(10)]\nprint(\"List input : {}\".format(input_list))\nprint(\"List selection sort : {}\".format(selectionSort(input_list)))\n\nList input : [56, 63, 14, 89, 98, 46, 23, 88, 67, 63]\nList selection sort : [14, 23, 46, 56, 63, 63, 67, 88, 89, 98]"
  },
  {
    "objectID": "posts/SelectionSort/SelectionSort.html#exercise-2",
    "href": "posts/SelectionSort/SelectionSort.html#exercise-2",
    "title": "Selection Sort",
    "section": "Exercise 2",
    "text": "Exercise 2\n\nA. Problem Statement\nProvide an example of recursion.\nThe implemented recursive function performs the addition of a scalar to a multidimensional array of integers or decimals. The base case of the function checks if it encounters an integer or decimal value; otherwise, it continues calling itself, traversing the entire array. Recursion allows solving this problem as it generalizes the algorithm, which does not happen if we implement it with the same iterative logic, as it only solves the problem for a predefined dimension.\n\ndef suma_escalar_array(arreglo, numero):\n    \"\"\"\n    funcion que permite sumar un escalar a una lista\n    Args:\n        arreglo:(list) arreglo al que se va sumar el numero escalar\n        numero (int or float) : escalar que va sumar al arreglo\n    Returns:\n        arreglo (list): arreglo sumado escalar\n    \"\"\"\n    if type(arreglo) is  int or type(arreglo) is float:\n        return arreglo+numero;\n    else :\n        for i in range(0,len(arreglo)) :\n            arreglo[i]=suma_escalar_array(arreglo[i], numero)\n    return arreglo\n\n\n\nB. Execution of the Function with Different Inputs\nTest the Recursive Function with a One-Dimensional Array\n\nprint(\"Result  : {}\".format(suma_escalar_array([1,2,3,4,5,6,7,8,9,10], 10)))\n\nResult  : [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]"
  },
  {
    "objectID": "posts/SelectionSort/SelectionSort.html#conclusions",
    "href": "posts/SelectionSort/SelectionSort.html#conclusions",
    "title": "Selection Sort",
    "section": "Conclusions",
    "text": "Conclusions\n\nThe implementation of selection sort carried out in Exercise 1 confirms the utility of selection sort as a tool for ordering a collection of data.\nThe selection sort algorithm implemented in Exercise 1 is composed of two functions: the first, findSmallest, which returns the index of the smallest element in the array, and the second, selectionSort, which adds this element to the new sorted list and removes it from the original array.\nThe efficiency of selection sort is $ O(n^{2}) $ operations to sort a list of n elements.\nThe recursive function addScalarToArray implemented in Exercise 2 generalizes the algorithm for adding a scalar to an array of different dimensions. In contrast, implementing the function with the same iterative logic only solves the problem for an array of predefined dimension.\nRecursion consists of one or more base cases. In the function in Exercise 2, the base case executes when the input value is an integer or decimal, and the recursive case occurs when the input value is a list.\nThe call stack in the function from Exercise 2 will depend on the dimensionality of the elements in the input array."
  },
  {
    "objectID": "posts/StableMachin/StableMachin.html",
    "href": "posts/StableMachin/StableMachin.html",
    "title": "Stable Matching",
    "section": "",
    "text": "Implement the stable matching algorithm and verify its functionality with different inputs."
  },
  {
    "objectID": "posts/StableMachin/StableMachin.html#objectives",
    "href": "posts/StableMachin/StableMachin.html#objectives",
    "title": "Stable Matching",
    "section": "",
    "text": "Implement the stable matching algorithm and verify its functionality with different inputs."
  },
  {
    "objectID": "posts/StableMachin/StableMachin.html#introduction",
    "href": "posts/StableMachin/StableMachin.html#introduction",
    "title": "Stable Matching",
    "section": "Introduction",
    "text": "Introduction\nIn 1962, researchers David Gale and Lloyd Shapley introduced a study on matching to assign a set of pairs with stability, also known as the stable marriage problem. Gale and Shapley used the typical situation of student selection in universities based on preferences as an example. The result of their research is a satisfactory assignment procedure that eliminates uncertainties (Gale and Shapley 1962). Today, a large number of applications are based on this algorithm, such as matching servers with potential users in internet services."
  },
  {
    "objectID": "posts/StableMachin/StableMachin.html#exercise-1-stable-matching",
    "href": "posts/StableMachin/StableMachin.html#exercise-1-stable-matching",
    "title": "Stable Matching",
    "section": "Exercise 1: Stable Matching",
    "text": "Exercise 1: Stable Matching\n\nProblem Statement\nIf we want to match two sets in pairs, with respect to the preferences of each element in the set, the stable matching algorithm presents a series of steps to ensure this matching is stable, and none of the paired elements is left alone or can break another pair.\nTo develop the algorithm, we will exemplify with a demo involving students applying to hospitals. A set of 5 students are sought by 5 hospitals (“Cs.princeton.edu”).\n\n\n\nHospital Preferences (“Cs.princeton.edu”)\n\n\n\n\n\nStudent Preferences (“Cs.princeton.edu”)\n\n\n\nimport random\ndef stableMatching( ):\n    requeridos=['ATLANTA','BOSTON','CHICAGO','DETROIT','EL PASO']\n    solicitantes=['VAL','WAYNE','XAVIER','YOLANDA','ZEUS']\n    preferencias={\n    'ATLANTA':['WAYNE','VAL','YOLANDA','ZEUS','XAVIER'],\n    'BOSTON':['YOLANDA','WAYNE','VAL','XAVIER','ZEUS'],\n    'CHICAGO':['WAYNE','ZEUS','XAVIER','YOLANDA','VAL'],\n    'DETROIT':['VAL','YOLANDA','XAVIER','WAYNE','ZEUS'],\n    'EL PASO':['WAYNE','YOLANDA','VAL','ZEUS','XAVIER'],\n        \n    'VAL':['EL PASO','ATLANTA','BOSTON','DETROIT','CHICAGO'],\n    'WAYNE':['CHICAGO','BOSTON','DETROIT','ATLANTA','EL PASO'],\n    'XAVIER':['BOSTON','CHICAGO','DETROIT','EL PASO','ATLANTA'],\n    'YOLANDA':['ATLANTA','EL PASO','DETROIT','CHICAGO','BOSTON'],\n    'ZEUS':['DETROIT','BOSTON','EL PASO','CHICAGO','ATLANTA'],\n    }\n    \n    random.shuffle(requeridos)###demostrar que no hay problema del orden\n    random.shuffle(solicitantes)###demostrar que no hay problema del orden\n    solicitantes_libres=list(solicitantes)\n    rank={}\n    for x in preferencias:\n        rank[x]=dict(zip(preferencias[x],range(1,len(preferencias[x])+1)))\n    for x in preferencias:\n        preferencias[x].reverse()\n    S={}\n    while solicitantes_libres :\n        solicitante=solicitantes_libres.pop()\n        if len(preferencias[solicitante])==0:\n            continue\n        requerido=preferencias[solicitante].pop()\n        if requerido not in S :\n            S[requerido]=solicitante\n        else :\n            Hompre_prime=S[requerido]\n            if rank[requerido][solicitante]&lt;rank[requerido][Hompre_prime]:     \n                S[requerido]=solicitante \n                solicitantes_libres.append(Hompre_prime)\n            else:\n                solicitantes_libres.append(solicitante)\n    print(S)\n\n\nstableMatching( )\n\n{'BOSTON': 'XAVIER', 'DETROIT': 'ZEUS', 'EL PASO': 'VAL', 'ATLANTA': 'YOLANDA', 'CHICAGO': 'WAYNE'}\n\n\n\n\nDoes the set S change if the order of elements in Entity1 changes?\nThe stable matching algorithm does not depend on the order of elements in the entities. The result of shuffling the elements of the entities (Applicants, Required) will always generate the same stable matching. Using the shuffle function in Python, we can randomize the order of the entities without affecting the final result.\n\nstableMatching( )\n\n{'EL PASO': 'VAL', 'CHICAGO': 'WAYNE', 'BOSTON': 'XAVIER', 'ATLANTA': 'YOLANDA', 'DETROIT': 'ZEUS'}\n\n\n\n\nDoes the set S change if we consider Entity 1 as Entity 2 and vice versa?\nThe result of swapping the identities (Applicants &lt;-&gt; Required) changes the outcome of the algorithm because, in the first case, it satisfies the preferences of the applicant Entity 1. When swapped, it satisfies the preferences of Entity 2. The results are:\n\n(Entity 1 = applicants = Hospitals), (Entity 2 = required = Students)\n\nThe result presents the stable pairs for this first case where the applicants are the hospitals and the required are the students. The algorithm satisfies the applicants (hospitals), meaning it is not equitable as it only satisfies the applicants’ preferences."
  },
  {
    "objectID": "posts/StableMachin/StableMachin.html#conclusions",
    "href": "posts/StableMachin/StableMachin.html#conclusions",
    "title": "Stable Matching",
    "section": "Conclusions",
    "text": "Conclusions\n\nThe stable matching algorithm allows us to pair two sets according to their preference lists, resulting in a set of stable pairs.\nThe outcome of the stable matching algorithm is independent of the order of the elements in the input entities.\nThe outcome of the stable matching algorithm always prioritizes the applicant entity since it chooses its best possible matches according to its preference list.\nThe stable matching algorithm is not equitable as it always satisfies the preferences of the entity that enters as the applicant.\nThe stable matching algorithm presents two results: one where the first entity is the applicant and the second entity is the required, and another by swapping the entities where the second entity is the applicant and the first entity is the required."
  },
  {
    "objectID": "posts/stravaFolium/Strava_gpx_plot.html",
    "href": "posts/stravaFolium/Strava_gpx_plot.html",
    "title": "Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python",
    "section": "",
    "text": "“Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python” is a tool that allows users to visualize their Strava activities on interactive maps. By using Python and the Folium library, this tool reads GPX files from Strava and plots the routes on a map, highlighting the beauty of each journey. Users can customize the maps, adding markers and different styles to enhance the visual appeal. This tool is perfect for athletes and outdoor enthusiasts who want to see their activities in a new light, making it easy to share and analyze their adventures.\nimport pandas as pd\nimport gpxpy\nimport gpxpy.gpx\nimport matplotlib.pyplot as plt\nimport os\nimport folium"
  },
  {
    "objectID": "posts/stravaFolium/Strava_gpx_plot.html#read-gpx-file",
    "href": "posts/stravaFolium/Strava_gpx_plot.html#read-gpx-file",
    "title": "Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python",
    "section": "Read gpx File",
    "text": "Read gpx File\n\n# path from gpx file\npath = \"Princesa_Toa_.gpx\"\n# load data from gpx strava activity and parse\nwith open(path, 'r') as gpx_file:\n    gpx = gpxpy.parse(gpx_file)"
  },
  {
    "objectID": "posts/stravaFolium/Strava_gpx_plot.html#extract-latitude-longitude-and-elevation",
    "href": "posts/stravaFolium/Strava_gpx_plot.html#extract-latitude-longitude-and-elevation",
    "title": "Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python",
    "section": "Extract latitude, longitude and elevation",
    "text": "Extract latitude, longitude and elevation\n\n# extract in gpx file latitude, longitude  and elevation\nroute_info = [{'latitude': point.latitude,'longitude': point.longitude,'elevation': point.elevation} \n              for track   in gpx.tracks  \n              for segment in track.segments \n              for point   in segment.points ]\n\n\n# route_df Dataframe\ndf = pd.DataFrame(route_info)\ndf.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\nelevation\n\n\n\n\n0\n-0.216083\n-78.436892\n2388.8\n\n\n1\n-0.216085\n-78.436895\n2388.8\n\n\n2\n-0.216141\n-78.436849\n2388.9\n\n\n3\n-0.216161\n-78.436832\n2388.9\n\n\n4\n-0.216211\n-78.436803\n2389.0\n\n\n\n\n\n\n\n\n# Calculate the middle index\nmiddle_index = len(df) // 2\n# Get the middle element using iloc\npoint  = df.iloc[middle_index]"
  },
  {
    "objectID": "posts/Strava_pydeck/StavaPydeckSegment.html",
    "href": "posts/Strava_pydeck/StavaPydeckSegment.html",
    "title": "Strava Information Plot pydeck",
    "section": "",
    "text": "#pip install pydeck\nimport pydeck as pdk\nimport pandas as pd\nimport ast"
  },
  {
    "objectID": "posts/Strava_pydeck/StavaPydeckSegment.html#read-dataset",
    "href": "posts/Strava_pydeck/StavaPydeckSegment.html#read-dataset",
    "title": "Strava Information Plot pydeck",
    "section": "Read Dataset",
    "text": "Read Dataset\n\ndf = pd.read_csv(\"dataset.csv\")\n\n\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 5817 entries, 0 to 5816\nData columns (total 10 columns):\n #   Column                Non-Null Count  Dtype  \n---  ------                --------------  -----  \n 0   id                    5817 non-null   object \n 1   distance              5817 non-null   float64\n 2   elevation_high        5817 non-null   float64\n 3   elevation_low         5817 non-null   float64\n 4   start_latlng          5817 non-null   object \n 5   climb_category        5817 non-null   int64  \n 6   total_elevation_gain  5817 non-null   float64\n 7   effort_count          5817 non-null   int64  \n 8   athlete_count         5817 non-null   int64  \n 9   star_count            5817 non-null   int64  \ndtypes: float64(4), int64(4), object(2)\nmemory usage: 454.6+ KB\n\n\n\nGet latitude and Longitude\n\ndf[\"start_latlng\"] = df.start_latlng.apply(ast.literal_eval)\ndf[\"lat\"] = df.start_latlng.apply(lambda x:x[0])\ndf[\"lng\"] = df.start_latlng.apply(lambda x:x[1])"
  },
  {
    "objectID": "posts/Strava_pydeck/StavaPydeckSegment.html#plot-elevation-high",
    "href": "posts/Strava_pydeck/StavaPydeckSegment.html#plot-elevation-high",
    "title": "Strava Information Plot pydeck",
    "section": "Plot Elevation High",
    "text": "Plot Elevation High\n\n\n\ncolumn_layer = pdk.Layer(\n    \"ColumnLayer\",\n    data=df,\n    get_position=[\"lng\", \"lat\"],\n    get_elevation=\"elevation_high\",\n    radius=50,\n    pickable=True,\n    auto_highlight=True,\n    get_fill_color = [\"252\",\"82\",\"0\" ,140]\n)\n\ntooltip = {\n    \"html\": \"&lt;b&gt;{elevation_high}&lt;/b&gt; meters elevation, climb category &lt;b&gt;{climb_category}&lt;/b&gt; NTD/sqm\",\n    \"style\": {\"background\": \"grey\", \"color\": \"white\", \"font-family\": '\"Helvetica Neue\", Arial', \"z-index\": \"10000\"},\n}\nview_state = pdk.ViewState(\n    longitude=-78.46576413139701,\n    latitude=-0.1988402847200632,\n    zoom=6,\n    min_zoom=9,\n    max_zoom=15,\n    pitch=40.5,\n    bearing=-27.36)\n\nr = pdk.Deck(\n    column_layer,\n    initial_view_state=view_state,\n    tooltip=tooltip,\n)\n\nr.to_html(\"column_layer.html\")\n\n\n        \n    \n\n\n\n# Define a layer to display on a map\nlayer = pdk.Layer(\n    \"HexagonLayer\",\n    df[[\"lng\", \"lat\",'elevation_high']],\n    get_position=[\"lng\", \"lat\"],\n    elevation_scale=50,\n    pickable=True,\n    elevation_range=[0, 1500],\n    extruded=True,\n    coverage=1,\n)\n\n\n# Set the viewport location -0.1988402847200632, -78.46576413139701\nview_state = pdk.ViewState(\n    longitude=-78.46576413139701,\n    latitude=-0.1988402847200632,\n    zoom=6,\n    min_zoom=8,\n    max_zoom=15,\n    pitch=40.5,\n    bearing=-27.36)\n\n\n# Render\nr = pdk.Deck(layers=[layer], initial_view_state=view_state)\nr.to_html(\"hexagon_layer.html\")"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  }
]