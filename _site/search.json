[
  {
    "objectID": "posts/stravaFolium/Strava_gpx_plot.html",
    "href": "posts/stravaFolium/Strava_gpx_plot.html",
    "title": "Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python",
    "section": "",
    "text": "“Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python” is a tool that allows users to visualize their Strava activities on interactive maps. By using Python and the Folium library, this tool reads GPX files from Strava and plots the routes on a map, highlighting the beauty of each journey. Users can customize the maps, adding markers and different styles to enhance the visual appeal. This tool is perfect for athletes and outdoor enthusiasts who want to see their activities in a new light, making it easy to share and analyze their adventures.\nimport pandas as pd\nimport gpxpy\nimport gpxpy.gpx\nimport matplotlib.pyplot as plt\nimport os\nimport folium"
  },
  {
    "objectID": "posts/stravaFolium/Strava_gpx_plot.html#read-gpx-file",
    "href": "posts/stravaFolium/Strava_gpx_plot.html#read-gpx-file",
    "title": "Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python",
    "section": "Read gpx File",
    "text": "Read gpx File\n\n# path from gpx file\npath = \"Princesa_Toa_.gpx\"\n# load data from gpx strava activity and parse\nwith open(path, 'r') as gpx_file:\n    gpx = gpxpy.parse(gpx_file)"
  },
  {
    "objectID": "posts/stravaFolium/Strava_gpx_plot.html#extract-latitude-longitude-and-elevation",
    "href": "posts/stravaFolium/Strava_gpx_plot.html#extract-latitude-longitude-and-elevation",
    "title": "Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python",
    "section": "Extract latitude, longitude and elevation",
    "text": "Extract latitude, longitude and elevation\n\n# extract in gpx file latitude, longitude  and elevation\nroute_info = [{'latitude': point.latitude,'longitude': point.longitude,'elevation': point.elevation} \n              for track   in gpx.tracks  \n              for segment in track.segments \n              for point   in segment.points ]\n\n\n# route_df Dataframe\ndf = pd.DataFrame(route_info)\ndf.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\nelevation\n\n\n\n\n0\n-0.216083\n-78.436892\n2388.8\n\n\n1\n-0.216085\n-78.436895\n2388.8\n\n\n2\n-0.216141\n-78.436849\n2388.9\n\n\n3\n-0.216161\n-78.436832\n2388.9\n\n\n4\n-0.216211\n-78.436803\n2389.0\n\n\n\n\n\n\n\n\n# Calculate the middle index\nmiddle_index = len(df) // 2\n# Get the middle element using iloc\npoint  = df.iloc[middle_index]"
  },
  {
    "objectID": "posts/PlotEcuador/HeatEcuador.html",
    "href": "posts/PlotEcuador/HeatEcuador.html",
    "title": "Ecuador Geo-Visualization: Heatmap by Region",
    "section": "",
    "text": "This project presents an interactive choropleth map of Ecuador using the Folium library, which combines Python with Leaflet.js for dynamic geographic visualizations. The objective is to visually represent region-based intensity data — such as metrics from surveys, socioeconomic indicators, or other analytics — on a province-level map of Ecuador."
  },
  {
    "objectID": "posts/PlotEcuador/HeatEcuador.html#create-synthetic-data-for-plot",
    "href": "posts/PlotEcuador/HeatEcuador.html#create-synthetic-data-for-plot",
    "title": "Ecuador Geo-Visualization: Heatmap by Region",
    "section": "Create Synthetic Data for Plot",
    "text": "Create Synthetic Data for Plot\n\n\ndata = pd.DataFrame({\n    \"intensidad\": np.random.uniform(0, 100, size=24)\n})\ndraw_map(data, \"intensidad\")\n\n&lt;positron-console-cell-19&gt;:35: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html",
    "href": "posts/BFS_DFS/BFS.html",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "",
    "text": "Implement the BFS (Breadth-First Search) and DFS (Depth-First Search) algorithms in Python.\nVerify that BFS calculates the path with the fewest edges between two vertices of the graph.\nVerify that DFS allows finding all vertices accessible from a source vertex of the graph."
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#objectives",
    "href": "posts/BFS_DFS/BFS.html#objectives",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "",
    "text": "Implement the BFS (Breadth-First Search) and DFS (Depth-First Search) algorithms in Python.\nVerify that BFS calculates the path with the fewest edges between two vertices of the graph.\nVerify that DFS allows finding all vertices accessible from a source vertex of the graph."
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#introduction",
    "href": "posts/BFS_DFS/BFS.html#introduction",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "2. Introduction",
    "text": "2. Introduction\nBFS is a way to find all vertices accessible from a source vertex of a graph. The search resembles a wave that hits all vertices starting from node 1 (beginning). The FIFO queue Q is used to maintain the wavefront, and control is kept over nodes already included in the wave to prevent them from being revisited. BFS allows obtaining the shortest path from the source node to the other connected nodes. The efficiency of BFS is O(number of vertices + number of edges), commonly written as O(V + E) (V for the number of vertices, E for the number of edges). BFS is used to solve the following problems:\n\nTesting if a graph is connected.\nCalculating the spanning forest of the graph.\nCalculating for each vertex in the graph, a path with the minimum number of edges between the initial vertex and the current vertex or informing that no such path exists.\n\nDFS (Depth-First Search) is a systematic way of finding all vertices accessible from a source vertex. Like breadth-first search, DFS traverses a connected component of a given graph and defines a spanning tree. The basic idea of depth-first search is the following: it systematically explores each edge. We start over from different vertices as needed. As soon as we discover a vertex, DFS starts exploring from it (unlike BFS, which places a vertex in a queue to explore later), only backtracking when necessary (Muniswamy 2013). DFS is used to solve the following problems:\n\nTesting if the graph is connected.\nCalculating the spanning forest of the graph.\nCalculating a path between two vertices of the graph or informing that no such path exists.\nCalculating a cycle in the graph or informing that no such cycle exists."
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#exercise-1",
    "href": "posts/BFS_DFS/BFS.html#exercise-1",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "3. Exercise 1",
    "text": "3. Exercise 1\n\nA. Problem Statement\nImplement the BFS algorithm to answer the following questions: 1. Is there a path from CAB to BAT? 2. What is that path?\n\n\n\n\n\ngraph TD\n    CAB  --&gt; CAT \n    CAB  --&gt; CAR\n    CAR --&gt; CAT\n    CAR --&gt; BAR\n    CAT --&gt; MAT\n    CAT --&gt; BAT\n    MAT --&gt; BAT\n    BAR --&gt; MAT\n\n\n\n\n\n\n\n\n\nB. Implementation in Python\nTo implement the BFS algorithm in Python, a queue is used to enqueue the neighbor nodes of each source node. In the BFS function, two dictionaries are created: one called marked to mark nodes that have already been enqueued, and edgeto to assign each node its preceding node.\n\nfrom collections import deque\n\ndef busqueda_BFS(name,graph):\n    \"\"\"\n    busqueda_BFS Search Algorithm\n\n    Args:\n        start (str): The starting node.\n        graph (dict): The graph represented as an adjacency list.\n\n    Returns:\n        edgeto (dict): A dictionary containing the parent nodes of the connected component.\n    \"\"\"\n    ##############ESTRUCTURAS AUXILIARES \n    marked= dict.fromkeys(graph.keys(),False)\n    marked[name]=True\n    edgeto={name:\"inicio\"}\n    edgeto.update(dict.fromkeys(graph[name],name))\n    marked.update(dict.fromkeys(graph[name],True))\n    ##############ESTRUCTURAS AUXILIARES \n    search_queue = deque()\n    search_queue += graph[name] \n    searched = [] \n    while search_queue:\n        person = search_queue.popleft() \n        if not person in searched: \n            comprueba=[ nodo  for nodo in graph[person] if marked[nodo]==False ]\n            edgeto.update(dict.fromkeys(comprueba,person))\n            marked.update(dict.fromkeys(comprueba,True))\n            search_queue += graph[person] \n            searched.append(person)\n    return edgeto\n\ndef ruta(busqueda,edgeto):\n    \"\"\" Retorna ruta del componente conectado nodo inico\n        Args:\n            edgeto :(dict) diccionario que estan los nodos padres del componete conectado\n            busqueda :(str) nodo buscar\n        return:\n            ruta list() : lista que contiene la ruta\n    \"\"\"\n    ruta=[]\n    if (busqueda in edgeto.keys()):\n        while busqueda !=\"inicio\":\n            ruta.insert(0,busqueda)\n            busqueda=edgeto[busqueda]   \n    return ruta\n\n\n\nC. Execution of the Algorithm\n\nThe graph is constructed using a Python dictionary where the key is the node, and the value is a list of the node’s neighbors. Note that the graph to be analyzed (Illustration) is directed, so only the target neighbors should be included.\n\n\ngraph = {}\ngraph[\"CAB\"] = [\"CAT\", \"CAR\"]\ngraph[\"CAR\"] = [\"CAT\", \"BAR\"]\ngraph[\"CAT\"] = [\"MAT\",\"BAT\"]\ngraph[\"MAT\"] = [\"BAT\"]\ngraph[\"BAR\"] = [\"MAT\"]\ngraph[\"BAT\"] = []\n\n\nedgeto=busqueda_BFS(\"CAB\",graph)\nedgeto\n\n{'CAB': 'inicio',\n 'CAT': 'CAB',\n 'CAR': 'CAB',\n 'MAT': 'CAT',\n 'BAT': 'CAT',\n 'BAR': 'CAR'}\n\n\n\nruta(\"BAT\",edgeto)\n\n['CAB', 'CAT', 'BAT']\n\n\n\n\n\n\n\ngraph TD\n    CAB --&gt; CAT\n    CAT --&gt; BAT\n\n\n\n\n\n\n\n\nrutas={nodo:ruta(nodo,edgeto) for nodo in edgeto.keys()}\nrutas\n\n{'CAB': ['CAB'],\n 'CAT': ['CAB', 'CAT'],\n 'CAR': ['CAB', 'CAR'],\n 'MAT': ['CAB', 'CAT', 'MAT'],\n 'BAT': ['CAB', 'CAT', 'BAT'],\n 'BAR': ['CAB', 'CAR', 'BAR']}\n\n\n\n\n\n\n\ngraph TD\n    CAB --&gt; CAT\n    CAB --&gt; CAR\n    CAT --&gt; MAT\n    CAT --&gt; BAT\n    CAR --&gt; BAR"
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#exercise-2",
    "href": "posts/BFS_DFS/BFS.html#exercise-2",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "4. Exercise 2",
    "text": "4. Exercise 2\n\nD. Problem Statement\nWhat are the DFS Trees for the following graph G, given that the starting node is 0? Implement the DFS algorithm (using the recursive method) and use the necessary auxiliary structures.\n\n\n\n\n\ngraph TD\n    0 &lt;--&gt; 2\n    0 &lt;--&gt; 1\n    0 &lt;--&gt; 5\n    1 &lt;--&gt; 2\n    2 &lt;--&gt; 3\n    2 &lt;--&gt; 4\n    3 &lt;--&gt; 5\n    3 &lt;--&gt; 4\n    6 &lt;--&gt; 7\n\n\n\n\n\n\n\n\ndef dfs( graph, node,visited=set()):\n    \"\"\"algortimo dfs\n        Args:\n            graph :(dict) diccionario que representa grafo\n            node :(str) nodo fuente o raiz\n            visited:control nodos visitados default set()\n        return:\n            ruta list() : lista que contiene la ruta\n    \"\"\"\n    if node not in visited: ##comparacion si el nodo no se ha visitad\n        print (node)##impresion de nodos visitados\n        visited.add(node) ##agregando nodos visitados\n        marked[node]=True##control de nodos visitados\n        for neighbour in graph[node]:\n            comprueba=[ nodo  for nodo in graph[node] if marked[nodo]==False ]##comprovacion\n            edgeto.update(dict.fromkeys(comprueba,node))##llenado de edgeto\n            dfs(graph, neighbour,visited)\n\n\ndef ruta_DFS(busqueda,edgeto):\n    \"\"\" Retorna ruta del componente conectado nodo inico\n        Args:\n            edgeto :(dict) diccionario que estan los nodos padres del componete conectado\n            busqueda :(str) nodo buscar\n        return:\n            ruta list() : lista que contiene la ruta\n    \"\"\"\n    ruta=[]\n    while busqueda !=\"\":\n        ruta.insert(0,busqueda)\n        busqueda=edgeto[busqueda]\n    return ruta\n\n\n\nExecution of the Algorithm\n\nDefine the graph and the starting node 0 as input parameters.\n\n\n#graph\ngraph = dict()\ngraph[\"0\"] = [\"2\", \"1\",\"5\"]\ngraph[\"1\"] = [\"0\", \"2\"]\ngraph[\"2\"] = [\"0\",\"1\",\"3\",\"4\"]\ngraph[\"3\"] = [\"5\",\"4\",\"2\"]\ngraph[\"4\"] = [\"3\",\"2\"]\ngraph[\"5\"] = [\"3\",\"0\"]\nmarked= dict.fromkeys(graph.keys(),False)\nedgeto= dict.fromkeys(graph.keys(),\"\")\n\n\nThe execution of DFS provides the complete edgeto structure, which allows generating the route tree of the connected component, the DFS Tree.\n\n\ndfs(graph,\"0\")\n\n0\n2\n1\n3\n5\n4\n\n\n\nTo obtain all the routes, the route function was executed with the edgeto obtained for each node, storing this result in the routes dictionary, which allows knowing the route from the origin to each node.\n\n\nedgeto\n\n{'0': '', '1': '2', '2': '0', '3': '2', '4': '3', '5': '3'}\n\n\n\nrutas={nodo:ruta_DFS(nodo,edgeto) for nodo in edgeto.keys()}\nrutas\n\n{'0': ['0'],\n '1': ['0', '2', '1'],\n '2': ['0', '2'],\n '3': ['0', '2', '3'],\n '4': ['0', '2', '3', '4'],\n '5': ['0', '2', '3', '5']}\n\n\n\n\n\n\n\ngraph TD\n 0 --&gt; 2\n 2 --&gt; 1\n 2 --&gt; 3\n 3 --&gt; 4\n 3 --&gt; 5"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Marco Aguirre",
    "section": "",
    "text": "Master of Computer Science with a focus on Intelligent Systems, seeking to provide support and solutions to optimize processes and make data-driven decisions. Passionate about problem-solving and innovation through data science."
  },
  {
    "objectID": "index.html#professional-summary",
    "href": "index.html#professional-summary",
    "title": "Marco Aguirre",
    "section": "",
    "text": "Master of Computer Science with a focus on Intelligent Systems, seeking to provide support and solutions to optimize processes and make data-driven decisions. Passionate about problem-solving and innovation through data science."
  },
  {
    "objectID": "index.html#professional-objective",
    "href": "index.html#professional-objective",
    "title": "Marco Aguirre",
    "section": "Professional Objective",
    "text": "Professional Objective\nTo apply my experience in Data Analysis, Machine Learning, Information Technology, and software development to solve complex problems and provide data-driven solutions that drive informed decision-making within an organization. Committed to the continuous pursuit of excellence in data science, exploring new techniques, and innovatively using technology to address business challenges."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Marco Aguirre",
    "section": "Education",
    "text": "Education\n\nMaster of Computer Science with a focus on Intelligent Systems | National Polytechnic School | Quito, Ecuador | 2021 - 2023|\nElectronics and Telecommunications Engineering |Armed Forces University - ESPE | Sangolqui, Ecuador | 2012 - 2018"
  },
  {
    "objectID": "index.html#professional-experience",
    "href": "index.html#professional-experience",
    "title": "Marco Aguirre",
    "section": "Professional Experience",
    "text": "Professional Experience\n\nResearch Technician | National Polytechnic School | 2021 - now | Management and analysis of research with data and its collection, cleaning, analysis, preprocessing, and modeling. Development of Data Mining projects.\nTechnical Support | FIXGROUP | 2019 - 2021 | Management of wireless links, design of hotspots, and managed Wi-Fi through Aruba.\nResearch Assistant | Armed Forces University ESPE | 2017 - 2018 | Management of wireless networks and exploration of new wireless communication technologies."
  },
  {
    "objectID": "index.html#publications",
    "href": "index.html#publications",
    "title": "Marco Aguirre",
    "section": "Publications",
    "text": "Publications\n\nGoSS-Rec: Group-Oriented Segment Sequence Recommendation\nAguirre, Marco; Recalde, Lorena; Loza-Aguirre, Edison\nInformation, Vol. 16, No. 8, Article 668, 2025.\nDOI: 10.3390/info16080668\nURL: https://www.mdpi.com/2078-2489/16/8/668\nA Graph-Based Analysis of Collaboration, Trends, and Ethical Dynamics: Perspectives on Ecuadorian Academic Research\nICEDEG 2025 - Eleventh International Conference on eDemocracy & eGovernment, 2025.\nDOI: 10.1109/ICEDEG65568.2025.11081533\nEvaluating embedded semantics for accessibility description of web crawl data\nAHFE International Conference, Vol. 94, 2023.\nDOI: 10.54941/ahfe1003774"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Marco Aguirre",
    "section": "",
    "text": "Mapa de Color tiempo\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nEcuador Geo-Visualization: Heatmap by Region\n\n\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nJul 26, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)\n\n\n\nnews\n\ncode\n\nalgorithms\n\nPython\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nStrava GPX Plotter: Mapping Beautiful Journeys with Folium in Python\n\n\n\nnews\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nStrava Route Plot OSMNX\n\n\n\nnews\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nMar 17, 2022\n\n\nMarco Aguirre\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notebooks.html",
    "href": "notebooks.html",
    "title": "Notebooks",
    "section": "",
    "text": "Mapa de Color tiempo\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nEcuador Geo-Visualization: Heatmap by Region\n\n\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nJul 26, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)\n\n\n\nnews\n\ncode\n\nalgorithms\n\nPython\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nStrava GPX Plotter: Mapping Beautiful Journeys with Folium in Python\n\n\n\nnews\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nStrava Route Plot OSMNX\n\n\n\nnews\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nMar 17, 2022\n\n\nMarco Aguirre\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html",
    "href": "posts/MapEcuador/folium_timeline.html",
    "title": "Mapa de Color tiempo",
    "section": "",
    "text": "The dataset was obtained from the USFQ Data Hub and from the following source:\nObjective:\nDevelop a georeferenced infographic that visualizes the voting results of the 2002 Ecuadorian presidential elections in Ecuador.\nimport folium\nimport pandas as pd\nimport geopandas as gpd\nimport branca\nimport json\nfrom folium.plugins import TimestampedGeoJson"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#handling-json-with-geopandas",
    "href": "posts/MapEcuador/folium_timeline.html#handling-json-with-geopandas",
    "title": "Mapa de Color tiempo",
    "section": "Handling JSON with GeoPandas",
    "text": "Handling JSON with GeoPandas\n\ndf_ecu = gpd.read_file(\"ecuador_provincias.json\")\ndf_ecu[\"name\"] = df_ecu[\"name\"].str.upper()\ndf_ecu.head()\n\n\n\n\n\n\n\n\nsource\nid\nname\ngeometry\n\n\n\n\n0\nhttps://simplemaps.com\nECE\nESMERALDAS\nMULTIPOLYGON (((-78.47812 1.18712, -78.47831 1...\n\n\n1\nhttps://simplemaps.com\nECC\nCARCHI\nPOLYGON ((-78.44211 0.87194, -78.44714 0.87437...\n\n\n2\nhttps://simplemaps.com\nECU\nSUCUMBIOS\nPOLYGON ((-77.81408 0.34566, -77.79186 0.37099...\n\n\n3\nhttps://simplemaps.com\nECD\nORELLANA\nPOLYGON ((-77.29941 -0.05855, -77.28401 -0.047...\n\n\n4\nhttps://simplemaps.com\nECY\nPASTAZA\nPOLYGON ((-77.05165 -1.01038, -77.07198 -1.033..."
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#dataset-etl-process",
    "href": "posts/MapEcuador/folium_timeline.html#dataset-etl-process",
    "title": "Mapa de Color tiempo",
    "section": "Dataset ETL Process",
    "text": "Dataset ETL Process\n\ndf = pd.read_csv(\"presidentes_votacion_cantonal_formato_angosto.csv\")\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 77462 entries, 0 to 77461\nData columns (total 9 columns):\n #   Column            Non-Null Count  Dtype \n---  ------            --------------  ----- \n 0   ANIO              77462 non-null  int64 \n 1   VUELTA            77462 non-null  int64 \n 2   PROVINCIA_CODIGO  77462 non-null  object\n 3   PROVINCIA_NOMBRE  77462 non-null  object\n 4   CANTON_CODIGO     77462 non-null  object\n 5   CANTON_NOMBRE     77462 non-null  object\n 6   CANDIDATO_NOMBRE  77462 non-null  object\n 7   AGRUPACION        77462 non-null  object\n 8   VOTOS             77462 non-null  int64 \ndtypes: int64(3), object(6)\nmemory usage: 5.3+ MB\n\n\n\n# agrupacion para obtener valos por provincia\ndf_gr = df.groupby([\"ANIO\", \"VUELTA\", \"PROVINCIA_NOMBRE\",\n        \"CANDIDATO_NOMBRE\",\"PROVINCIA_CODIGO\"])[\"VOTOS\"].sum().reset_index()\n# solo datos de Ecuador continental \ndf_gr = df_gr[~df_gr[\"PROVINCIA_NOMBRE\"].isin(['EUROPA, ASIA, '\n'OCEANIA', 'NORTE-AMERICA', 'LATAM, CARIBE, AFRICA'])]\n# agrupacion por voto mayoritario en provinica\ndf_max = df_gr.loc[\n    df_gr.groupby(['PROVINCIA_NOMBRE','ANIO','VUELTA'])['VOTOS'].idxmax()\n]"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#working-with-the-.json-file",
    "href": "posts/MapEcuador/folium_timeline.html#working-with-the-.json-file",
    "title": "Mapa de Color tiempo",
    "section": "Working with the .json File",
    "text": "Working with the .json File\n\n# Load Ecuador's GeoJSON data\nwith open(\"ecuador_provincias.json\", \"r\", encoding=\"utf-8\") as f:\n    geo_json_data = json.load(f)\ndf_max.PROVINCIA_NOMBRE.unique()\n\narray(['AZUAY', 'BOLIVAR', 'CANAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI', 'EL ORO', 'ESMERALDAS', 'GALAPAGOS',\n       'GUAYAS', 'IMBABURA', 'LOJA', 'LOS RIOS', 'MANABI', 'MORONA SANTIAGO', 'NAPO', 'ORELLANA', 'PASTAZA',\n       'PICHINCHA', 'SANTA ELENA', 'STO DGO TSACHILAS', 'SUCUMBIOS', 'TUNGURAHUA', 'ZAMORA CHINCHIPE'],\n      dtype=object)\n\n\n\n# Nombre de la provincias \nnombresGjson = sorted([x['properties'][\"name\"].upper() for x in geo_json_data['features']])\n# nombres a cambiar CAÑAR ,'SANTO DOMINGO DE LOS TSÁCHILAS' cambio en el dataset\ndf_max[\"PROVINCIA_NOMBRE\"] = df_max[\"PROVINCIA_NOMBRE\"].replace({'CANAR':'CAÑAR',\n                        'STO DGO TSACHILAS':'SANTO DOMINGO DE LOS TSÁCHILAS'})\ndf_max[\"PROVINCIA_NOMBRE\"].unique()\n\narray(['AZUAY', 'BOLIVAR', 'CAÑAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI', 'EL ORO', 'ESMERALDAS', 'GALAPAGOS',\n       'GUAYAS', 'IMBABURA', 'LOJA', 'LOS RIOS', 'MANABI', 'MORONA SANTIAGO', 'NAPO', 'ORELLANA', 'PASTAZA',\n       'PICHINCHA', 'SANTA ELENA', 'SANTO DOMINGO DE LOS TSÁCHILAS', 'SUCUMBIOS', 'TUNGURAHUA',\n       'ZAMORA CHINCHIPE'], dtype=object)"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#map-style",
    "href": "posts/MapEcuador/folium_timeline.html#map-style",
    "title": "Mapa de Color tiempo",
    "section": "Map Style",
    "text": "Map Style\n\n# COLORES POR CANDIDATO\nmapa_colores ={'ALVARO NOBOA':\"#980BEF\", 'JACOBO BUCARAM':\"#1070B9\", 'LUCIO GUTIERREZ':\"#E01212\",\n       'RODRIGO BORJA':\"#FEB00A\", 'XAVIER NEIRA':\"#F6FE69\",'RAFAEL CORREA':\"#07F93F\",\n       'LENIN MORENO':\"#07F93F\",'YAKU PEREZ':\"#F9D107\",'GUILLERMO LASSO':\"#1070B9\",\n         'LUISA GONZALEZ':\"#34FFF8\",'DANIEL NOBOA':\"#980BEF\", 'NULOS':\"#FFFFFF\",\n       'FERNANDO VILLAVICENCIO':\"#96B0FF\",'XAVIER HERVAS':\"#F9D107\", \n       'ANDRES ARAUZ':\"#07F93F\"\n       }\n# aplicar color al dataset\ndf_max['COLOR'] = df_max['CANDIDATO_NOMBRE'].apply(lambda x:mapa_colores.get(x))\ndf_max.head()\n\n\n\n\n\n\n\n\nANIO\nVUELTA\nPROVINCIA_NOMBRE\nCANDIDATO_NOMBRE\nPROVINCIA_CODIGO\nVOTOS\nCOLOR\n\n\n\n\n10\n2002\n1\nAZUAY\nRODRIGO BORJA\nEC01\n157246\n#FEB00A\n\n\n290\n2002\n2\nAZUAY\nLUCIO GUTIERREZ\nEC01\n371564\n#E01212\n\n\n397\n2006\n1\nAZUAY\nRAFAEL CORREA\nEC01\n166524\n#07F93F\n\n\n765\n2006\n2\nAZUAY\nRAFAEL CORREA\nEC01\n429830\n#07F93F\n\n\n879\n2009\n1\nAZUAY\nRAFAEL CORREA\nEC01\n418082\n#07F93F\n\n\n\n\n\n\n\n\ndef generar_start_end(row, col_anio='ANIO', col_vuelta='VUELTA'):\n    \"\"\"\n    Devuelve start y end como timestamps (ms) según:\n    - Vuelta 1: del 1 de enero al 1 de julio\n    - Vuelta 2: del 2 de julio al 31 diciembre\n    \"\"\"\n    anio = int(row[col_anio])\n    vuelta = int(row[col_vuelta])\n\n    if vuelta == 1:\n        start = pd.Timestamp(f\"{anio}-01-01 00:00:00\")\n        end   = pd.Timestamp(f\"{anio}-07-01 00:00:00\")\n    else:  # vuelta 2\n        start = pd.Timestamp(f\"{anio}-07-02 00:00:00\")\n        end   = pd.Timestamp(f\"{anio}-12-31 23:59:59\")\n\n    # convertir a timestamp en milisegundos\n    return {\n        'start': float(start.value // 10**6),\n        'end':   float(end.value   // 10**6)\n    }\n\n\ndf_max['start_end'] = df_max.apply(lambda x :\ngenerar_start_end(x, col_anio='ANIO', col_vuelta='VUELTA'),\n    axis=1\n)\n\n\ndf_merged = df_max.merge(df_ecu[['name', 'geometry']], \n                         left_on='PROVINCIA_NOMBRE', \n                         right_on='name', \n                         how='inner')\n# Convertir en GeoDataFrame\ngdf_final = gpd.GeoDataFrame(df_merged, geometry='geometry')"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#feature-generation-for-the-timeline",
    "href": "posts/MapEcuador/folium_timeline.html#feature-generation-for-the-timeline",
    "title": "Mapa de Color tiempo",
    "section": "Feature Generation for the Timeline",
    "text": "Feature Generation for the Timeline\n\n\nfeatures = []\n\nfor _, row in gdf_final.iterrows():\n\n    start_ts = int(row['start_end']['start']) // 1000  # segundos UNIX\n\n    start_date = pd.to_datetime(start_ts, unit='s').strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    feature = {\n        \"type\": \"Feature\",\n        \"geometry\": row[\"geometry\"].__geo_interface__,\n        \"properties\": {\n            \"time\": start_date,\n            \"style\": {\n                \"color\": \"black\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                \"fillColor\": row[\"COLOR\"],\n                \"fillOpacity\": 0.8\n            },\n            \"tooltip\": f\"Provincia: {row['PROVINCIA_NOMBRE']} - {row['CANDIDATO_NOMBRE']}\",\n            \"popup\": (\n                f\"&lt;b&gt;Provincia:&lt;/b&gt; {row['PROVINCIA_NOMBRE']}&lt;br&gt;\"\n                f\"&lt;b&gt;Candidato:&lt;/b&gt; {row['CANDIDATO_NOMBRE']}&lt;br&gt;\"\n                f\"&lt;b&gt;Votos:&lt;/b&gt; {row['VOTOS']}&lt;br&gt;\"\n                f\"&lt;b&gt;Año:&lt;/b&gt; {row['ANIO']} - Vuelta {row['VUELTA']}\"\n            )\n        }\n    }\n    features.append(feature)\n\n\nBase Map\n\nm = folium.Map(\n    location=[-0.19899731681836336, -78.4428000494774],\n    tiles=\"Cartodb dark_matter\", ## estilo del fondo mapa\n    zoom_start=6\n)\n\n\n\nAdding a Temporal Layer\n\nts = TimestampedGeoJson(\n    {\n        \"type\": \"FeatureCollection\",\n        \"features\": features,\n    },\n    period=\"P1Y\",\n    duration=\"P1Y\",\n    add_last_point=True,\n    auto_play=False,\n    loop=False\n).add_to(m)"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#legend-candidate-and-color-and-final-visualization",
    "href": "posts/MapEcuador/folium_timeline.html#legend-candidate-and-color-and-final-visualization",
    "title": "Mapa de Color tiempo",
    "section": "Legend (Candidate and Color) and Final Visualization",
    "text": "Legend (Candidate and Color) and Final Visualization\n\nitems_html = \"\"\nfor candidato, color in mapa_colores.items():\n    items_html += f'''\n    &nbsp; &lt;i class=\"fa fa-square\" style=\"color:{color};\"&gt;&lt;/i&gt;\n    &nbsp; {candidato}&lt;br&gt;'''\n\nlegend_html = f\"\"\"\n{{% macro html(this, kwargs) %}}\n&lt;div style=\"\n     position: fixed;\n     bottom: 50px; left: 50px;\n     width: 250px;\n     border:2px solid grey;\n     z-index:9999;\n     font-size:14px;\n     background-color:white;\n     opacity: 0.9;\n     padding: 10px;\n     border-radius: 5px;\"&gt;\n     &lt;b&gt;🗳️ Candidato ganador&lt;/b&gt;&lt;br&gt;\n     {items_html}\n&lt;/div&gt;\n{{% endmacro %}}\n\"\"\"\n\nlegend = branca.element.MacroElement()\nlegend._template = branca.element.Template(legend_html)\nm.get_root().add_child(legend)\n\nm.save(\"VotEcuador_Timeline_Legend.html\")\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html",
    "href": "posts/post-with-code/stravaPlotOSMNX.html",
    "title": "Strava Route Plot OSMNX",
    "section": "",
    "text": "Strava Route Plot using OSMnx involves visualizing and analyzing running or cycling routes recorded with the Strava app on maps generated with the OSMnx library. OSMnx is a Python package that allows users to download, model, and visualize street networks from OpenStreetMap’s data.\nimport osmnx as ox\nimport pandas as pd\nimport gpxpy\nimport gpxpy.gpx\nimport matplotlib.pyplot as plt\nimport polyline"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#read-route",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#read-route",
    "title": "Strava Route Plot OSMNX",
    "section": "1. Read Route",
    "text": "1. Read Route\n\npath = \"Princesa_Toa_.gpx\"\nwith open(path, 'r') as gpx_file:\n    gpx = gpxpy.parse(gpx_file)\n    \n# extract in gpx file latitude, longitude  and elevation\nroute_info = [{'latitude': point.latitude,'longitude': point.longitude,'elevation': point.elevation} \n              for track   in gpx.tracks  \n              for segment in track.segments \n              for point   in segment.points ]\n# route_df Dataframe\nroute_df = pd.DataFrame(route_info)\nroute_df.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\nelevation\n\n\n\n\n0\n-0.216083\n-78.436892\n2388.8\n\n\n1\n-0.216085\n-78.436895\n2388.8\n\n\n2\n-0.216141\n-78.436849\n2388.9\n\n\n3\n-0.216161\n-78.436832\n2388.9\n\n\n4\n-0.216211\n-78.436803\n2389.0"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#center-point-for-graph-in-ox",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#center-point-for-graph-in-ox",
    "title": "Strava Route Plot OSMNX",
    "section": "2. Center point for Graph in ox",
    "text": "2. Center point for Graph in ox\nLink osmnx graph_from_point fuction https://osmnx.readthedocs.io/en/stable/osmnx.html?highlight=graph_from_point#osmnx.graph.graph_from_point\n\n# center point to extract graph latitude , longitude\ncenter_point = (-0.26428048222240524, -78.4202862684383)\nG = ox.graph_from_point(center_point, dist=12000, retain_all=True, simplify = False, network_type='all')\n#bike all"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#plot-route",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#plot-route",
    "title": "Strava Route Plot OSMNX",
    "section": "3. Plot Route",
    "text": "3. Plot Route\n\nfig, ax = ox.plot_graph(G, node_size=0,\n                        figsize        = (11, 16), \n                        dpi            = 300,\n                        save           = False,\n                        bgcolor        = \"#FFFFFF\",\n                        edge_color     = \"#253951\",\n                        edge_alpha     = 0.2 ,\n                        show           = False)\n## Plot  activity in graph \nplt.plot( route_df['longitude'] , route_df['latitude'] ,\n         color     = \"#E64E25\" , \n         linewidth = 2.0)\n## Plot  activity in graph \nplt.show()\nfig.tight_layout(pad=0)\n## path name to save\npath_save = path.split(\".\")[0] + \".png\"\n# fig.savefig( path_save, dpi=300, format=\"png\", bbox_inches='tight',\n#             facecolor=fig.get_facecolor(), transparent=False)\n\n\n\n\n\n\n\n\n\n# save figure\nfig.savefig('activity.png')"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#plot-elevation",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#plot-elevation",
    "title": "Strava Route Plot OSMNX",
    "section": "4. Plot Elevation",
    "text": "4. Plot Elevation\n\nelevation = route_df.elevation\nx_plot    = range(len(elevation))\nmin_elev  = min(elevation) - 25\n\n\n# Set the figure size\nfig, ax = plt.subplots(figsize=(11, 2))\n# Area plot\nax.fill_between(x_plot, elevation, color=\"#E64E25\")\n# Set the minimum and maximum values for the y-axis\nax.set_ylim(min_elev, 4000)\nplt.axis('off')\n# Save the figure\npath_save = path.split(\".\")[0] +\"_elevation\" \".png\"\nplt.savefig(path_save , transparent=True, bbox_inches='tight', pad_inches=0 )\n# Display the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nfig.savefig('perfil.png')"
  }
]