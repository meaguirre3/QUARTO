[
  {
    "objectID": "posts/WordCloud/WordCloud.html",
    "href": "posts/WordCloud/WordCloud.html",
    "title": "Word Cloud",
    "section": "",
    "text": "Una nube de palabras (también conocida como nube de etiquetas o word cloud) es una representación visual de las palabras que conforman un texto o conjunto de textos, donde el tamaño de cada palabra es proporcional a su frecuencia o importancia dentro del texto. Cuanto más aparece una palabra, o más relevante sea, mayor y más destacada se mostrará."
  },
  {
    "objectID": "posts/WordCloud/WordCloud.html#usos-comunes",
    "href": "posts/WordCloud/WordCloud.html#usos-comunes",
    "title": "Word Cloud",
    "section": "0.1 Usos comunes",
    "text": "0.1 Usos comunes\n\nVisualizar ideas clave o temas frecuentes de manera rápida y atractiva.\n\nMostrar etiquetas en sitios web o blogs, resaltando los temas principales para mejorar la navegación o la experiencia del usuario.\n\nExplorar datos textuales cualitativos como respuestas de encuestas o comentarios, identificando tendencias o palabras más mencionadas.\n\nResumen visual de textos extensos (investigaciones, manuales, artículos académicos o reseñas de productos), ayudando a captar rápidamente los puntos centrales.\nApoyo en presentaciones y marketing, como elemento visual en infografías o slides para captar la atención del público.\n\nHerramienta interactiva en dinámicas grupales, ideal para captar opiniones del público, romper el hielo o generar debates durante talleres, reuniones o clases.\nExploración rápida de temas principales en investigación textual, útil como vista previa antes de análisis más profundos (“previewing” de temas, personajes o conceptos)."
  },
  {
    "objectID": "posts/WordCloud/WordCloud.html#características",
    "href": "posts/WordCloud/WordCloud.html#características",
    "title": "Word Cloud",
    "section": "0.2 Características",
    "text": "0.2 Características\n\nEstética visual: A menudo presentan colores variados y disposición dispersa, lo que les da un aspecto atractivo aunque la elección de color puede ser meramente decorativa.\n\nLimitaciones analíticas: Son útiles para obtener una vista general, pero no ofrecen contexto semántico ni relaciones profundas entre palabras."
  },
  {
    "objectID": "posts/WordCloud/WordCloud.html#errores-a-evitar",
    "href": "posts/WordCloud/WordCloud.html#errores-a-evitar",
    "title": "Word Cloud",
    "section": "0.3 Errores a evitar",
    "text": "0.3 Errores a evitar\n\nPreprocesar el texto: Fusiona sinónimos, aplica stemming* o lematización, y limpia palabras redundantes o irrelevantes (“stopwords”).\n\nLimitar el número de palabras: Mostrar solo las más relevantes mejora la claridad.\nElegir diseño con propósito: Usa fuentes legibles, colores que tengan significado.\nComplementar con otras visualizaciones: Usa gráficos de barras, tablas o análisis semántico para respaldar la nube con datos precisos y contexto."
  },
  {
    "objectID": "posts/WordCloud/WordCloud.html#características-principales",
    "href": "posts/WordCloud/WordCloud.html#características-principales",
    "title": "Word Cloud",
    "section": "1.1 Características principales",
    "text": "1.1 Características principales\n\nPermite personalizar colores, fuentes y tamaño de las palabras.\nAdmite enmascarar la nube con cualquier forma o imagen (por ejemplo, un corazón, una estrella o un logotipo), gracias a su integración con Pillow."
  },
  {
    "objectID": "posts/WordCloud/WordCloud.html#instalación",
    "href": "posts/WordCloud/WordCloud.html#instalación",
    "title": "Word Cloud",
    "section": "1.2 Instalación",
    "text": "1.2 Instalación\nPara instalar wordcloud junto con sus dependencias más comunes:\npip install wordcloud\npip install pillow\n\n::: {#6e5c724c .cell execution_count=31}\n``` {.python .cell-code}\n#pip install pillow\n:::\n\n#pip install wordcloud"
  },
  {
    "objectID": "posts/WordCloud/WordCloud.html#iteracion-1",
    "href": "posts/WordCloud/WordCloud.html#iteracion-1",
    "title": "Word Cloud",
    "section": "2.1 Iteracion 1",
    "text": "2.1 Iteracion 1\n\n\n# Extraer la columna de títulos de artículos\ntextos = df[\"NOMBRE ARTICULO\"].dropna().astype(str)\n\n# Unir todos los títulos en un solo texto\ntexto_unido = \" \".join(textos)\n\n# Stopwords \nstopwords = set(STOPWORDS)\n\n# Crear la nube de palabras\nnube = WordCloud(\n    width=1000,\n    height=600,\n    background_color=\"white\",\n    stopwords=stopwords,\n    colormap=\"viridis\"  # paleta de colores (puedes cambiar)\n).generate(texto_unido)\n\n# Mostrar la nube\nplt.figure(figsize=(12, 7))\nplt.imshow(nube, interpolation=\"bilinear\")\nplt.axis(\"off\")\nplt.show()"
  },
  {
    "objectID": "posts/WordCloud/WordCloud.html#iteracion-2",
    "href": "posts/WordCloud/WordCloud.html#iteracion-2",
    "title": "Word Cloud",
    "section": "2.2 Iteracion 2",
    "text": "2.2 Iteracion 2\nAgregar stopwords en español.\n\nwith open(\"stopwords-es.txt\", \"r\", encoding=\"utf-8\") as f:\n    stopwords_es = list([line.strip() for line in f if line.strip()])\nstopwords_es[10:20]\n\n['_',\n 'a',\n 'actualmente',\n 'acuerdo',\n 'adelante',\n 'ademas',\n 'además',\n 'adrede',\n 'afirmó',\n 'agregó']\n\n\n\n#agrega los de esp\nstopwords = set(list(STOPWORDS)+ stopwords_es )\n#forma circula \nimport numpy as np\nx, y = np.ogrid[:300, :300]\nmask = (x - 150) ** 2 + (y - 150) ** 2 &gt; 130 ** 2\nmask = 255 * mask.astype(int)\n# Crear la nube de palabras\nnube = WordCloud(\n    width=1000,\n    height=600,\n    background_color=\"white\",\n    stopwords=stopwords,\n    colormap=\"viridis\" , # paleta de colores (puedes cambiar)\n    mask=mask\n).generate(texto_unido)\n\nplt.imshow(nube, interpolation=\"bilinear\")\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# imagen procesamiento\n\nfrom PIL import Image, ImageOps\nmask_img = Image.open(\"SiluetEcuador.png\").convert(\"L\")  \n\nmask = np.array(mask_img)\n\n#agrega los de esp\nstopwords = set(list(STOPWORDS)+ stopwords_es )\n\n# Crear la nube de palabras\nnube = WordCloud(\n    width=1000,\n    height=700,\n    background_color=\"white\",\n    stopwords=stopwords,\n    colormap=\"viridis\" , # paleta de colores (puedes cambiar)\n    mask=mask\n).generate(texto_unido)\n\nplt.imshow(nube, interpolation=\"bilinear\")\nplt.axis(\"off\")\nplt.show()"
  },
  {
    "objectID": "posts/WordCloud/WordCloud.html#realice-un-wordcloud-de-articulos-de-la-universidad-san-francisco",
    "href": "posts/WordCloud/WordCloud.html#realice-un-wordcloud-de-articulos-de-la-universidad-san-francisco",
    "title": "Word Cloud",
    "section": "2.3 Realice un WordCloud de articulos de la Universidad San Francisco",
    "text": "2.3 Realice un WordCloud de articulos de la Universidad San Francisco\n\ndf.columns\n\nIndex(['AÑO', 'TIPO', 'NOMBRE UNIVERSIDAD', 'TIPO FINANCIAMIENTO',\n       'PROVINCIA UNIVERSIDAD', 'BASE DATOS INDEXADA', 'NOMBRE REVISTA',\n       'NOMBRE ARTICULO', 'CAMPO AMPLIO', 'CAMPO ESPECIFICO',\n       'CAMPO DETALLADO'],\n      dtype='object')\n\n\n\n# Extraer la columna de títulos de artículos\ntextos = df[df['NOMBRE UNIVERSIDAD']==\"UNIVERSIDAD SAN FRANCISCO DE QUITO\"][\"NOMBRE ARTICULO\"].dropna().astype(str)\n\n#agrega los de esp\nstopwords = set(list(STOPWORDS)+ stopwords_es )\n# imagen procesamiento\nmask_img = Image.open(\"usfq.png\").convert(\"L\")  \n\nmask = np.array(mask_img)\n\n\n# Crear la nube de palabras\nnube = WordCloud(\n    width=1000,\n    height=600,\n    background_color=\"white\",\n    stopwords=stopwords,\n    colormap=\"Reds\" , # paleta de colores (puedes cambiar)\n    mask=mask\n).generate(texto_unido)\n\nplt.imshow(nube, interpolation=\"bilinear\")\nplt.axis(\"off\")\nplt.show()"
  },
  {
    "objectID": "posts/valor_dataviz/index.html#historia",
    "href": "posts/valor_dataviz/index.html#historia",
    "title": "Valor de la Visualización de Datos",
    "section": "Historia",
    "text": "Historia\n\nSiglo XVII: mapas y primeras gráficas estadísticas."
  },
  {
    "objectID": "posts/valor_dataviz/index.html#historia-1",
    "href": "posts/valor_dataviz/index.html#historia-1",
    "title": "Valor de la Visualización de Datos",
    "section": "Historia",
    "text": "Historia\n\n1800s: nacimiento del gráfico circular de sectores y de barras., William Playfair.\nLas computadoras hicieron posible procesar grandes cantidades de datos a velocidades muy altas."
  },
  {
    "objectID": "posts/valor_dataviz/index.html#valor-de-la-palabra-roja",
    "href": "posts/valor_dataviz/index.html#valor-de-la-palabra-roja",
    "title": "Valor de la Visualización de Datos",
    "section": "Valor de la palabra roja",
    "text": "Valor de la palabra roja\n\nGet in bed\nCount sheep"
  },
  {
    "objectID": "posts/stravaFolium/Strava_gpx_plot.html",
    "href": "posts/stravaFolium/Strava_gpx_plot.html",
    "title": "Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python",
    "section": "",
    "text": "“Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python” is a tool that allows users to visualize their Strava activities on interactive maps. By using Python and the Folium library, this tool reads GPX files from Strava and plots the routes on a map, highlighting the beauty of each journey. Users can customize the maps, adding markers and different styles to enhance the visual appeal. This tool is perfect for athletes and outdoor enthusiasts who want to see their activities in a new light, making it easy to share and analyze their adventures.\nimport pandas as pd\nimport gpxpy\nimport gpxpy.gpx\nimport matplotlib.pyplot as plt\nimport os\nimport folium"
  },
  {
    "objectID": "posts/stravaFolium/Strava_gpx_plot.html#read-gpx-file",
    "href": "posts/stravaFolium/Strava_gpx_plot.html#read-gpx-file",
    "title": "Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python",
    "section": "Read gpx File",
    "text": "Read gpx File\n\n# path from gpx file\npath = \"Princesa_Toa_.gpx\"\n# load data from gpx strava activity and parse\nwith open(path, 'r') as gpx_file:\n    gpx = gpxpy.parse(gpx_file)"
  },
  {
    "objectID": "posts/stravaFolium/Strava_gpx_plot.html#extract-latitude-longitude-and-elevation",
    "href": "posts/stravaFolium/Strava_gpx_plot.html#extract-latitude-longitude-and-elevation",
    "title": "Strava GPX Plotter: Mapping Beautiful Journeys with Folium in Python",
    "section": "Extract latitude, longitude and elevation",
    "text": "Extract latitude, longitude and elevation\n\n# extract in gpx file latitude, longitude  and elevation\nroute_info = [{'latitude': point.latitude,'longitude': point.longitude,'elevation': point.elevation} \n              for track   in gpx.tracks  \n              for segment in track.segments \n              for point   in segment.points ]\n\n\n# route_df Dataframe\ndf = pd.DataFrame(route_info)\ndf.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\nelevation\n\n\n\n\n0\n-0.216083\n-78.436892\n2388.8\n\n\n1\n-0.216085\n-78.436895\n2388.8\n\n\n2\n-0.216141\n-78.436849\n2388.9\n\n\n3\n-0.216161\n-78.436832\n2388.9\n\n\n4\n-0.216211\n-78.436803\n2389.0\n\n\n\n\n\n\n\n\n# Calculate the middle index\nmiddle_index = len(df) // 2\n# Get the middle element using iloc\npoint  = df.iloc[middle_index]"
  },
  {
    "objectID": "posts/Semana1/introduccion_python_1.html",
    "href": "posts/Semana1/introduccion_python_1.html",
    "title": "Introducción a Python I",
    "section": "",
    "text": "Este documento introduce a conceptos basicos de la programación de Python, como variables tipo de datos y sus respectivas operaciones.\n\n1 Variables\n\n\n# Esto es un comentario\nspam = 1  # Esto también es un comentario\ntext = \"# Esto NO es un comentario porque está dentro de comillas.\"\nprint(spam, text)\n\n1 # Esto NO es un comentario porque está dentro de comillas.\n\n\n\n1 # Esto NO es un comentario porque está dentro de comillas.\n\n1\n\n\n\n\n# Números\nentero = 10\ndecimal = 3.14\n\n# Cadenas\ntexto = \"Hola, Python\"\n\n# Booleanos\nverdadero = True\nfalso = False\n\nprint(type(entero), type(decimal), type(texto), type(verdadero))\n\n&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'str'&gt; &lt;class 'bool'&gt;\n\n\n\n\nprint(2 + 2)\nprint(50 - 5*6)\nprint((50 - 5*6) / 4)\nprint(8 / 5)  # división devuelve float\nprint(17 // 3)  # división entera\nprint(17 % 3)   # residuo\nprint(5 ** 2)   # potencias\n\n4\n20\n5.0\n1.6\n5\n2\n25\n\n\n\n4\n20\n5.0\n1.6\n5\n2\n25\n\n25\n\n\n\n\nprint('spam eggs')\nprint(\"Paris rabbit got your back :)! Yay!\")\n\ns = 'First line.\\nSecond line.'\nprint(s)  # con caracteres especiales\nprint(r'C:\\some\\name')  # raw string\n\nspam eggs\nParis rabbit got your back :)! Yay!\nFirst line.\nSecond line.\nC:\\some\\name\n\n\n\nspam eggs\nParis rabbit got your back :)! Yay!\nFirst line.\nSecond line.\nC:\\some\\name\n\n\n  Cell In[28], line 2\n    Paris rabbit got your back :)! Yay!\n                                ^\nSyntaxError: unmatched ')'\n\n\n\n\n\n\nprint(3 * 'un' + 'ium')\nprint('Py' 'thon')\nprefix = 'Py'\nprint(prefix + 'thon')\n\n\nunununium\nPython\nPython\n\n\n\nword = 'Python'\nprint(word[0])   # primer carácter\nprint(word[-1])  # último carácter\nprint(word[0:2]) # subcadena\nprint(word[:2] + word[2:])\n\n\nP\nn\nPy\nPython\n\n\n\ns = 'supercalifragilisticexpialidocious'\nprint(len(s))\n\n\n34\n\n\n\nsquares = [1, 4, 9, 16, 25]\nprint(squares)\nprint(squares[0])\nprint(squares[-1])\nprint(squares[-3:])\nprint(squares + [36, 49, 64, 81, 100])\n\n\n[1, 4, 9, 16, 25]\n1\n25\n[9, 16, 25]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\n\ncubes = [1, 8, 27, 65, 125]\ncubes[3] = 64\ncubes.append(216)\ncubes.append(7 ** 3)\nprint(cubes)\n\n\n[1, 8, 27, 64, 125, 216, 343]\n\n\n\nletters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\nletters[2:5] = ['C', 'D', 'E']\nprint(letters)\nletters[2:5] = []\nprint(letters)\nletters[:] = []\nprint(letters)\n\n\n['a', 'b', 'C', 'D', 'E', 'f', 'g']\n['a', 'b', 'f', 'g']\n[]\n\n\n\nletters = ['a', 'b', 'c', 'd']\nprint(len(letters))\n\n\n4\n\n\n\na = ['a', 'b', 'c']\nn = [1, 2, 3]\nx = [a, n]\nprint(x)\nprint(x[0][1])\n\n\n[['a', 'b', 'c'], [1, 2, 3]]\nb\n\n\n\nx = 5\nif x &gt; 0:\n    print(\"x es positivo\")\nelif x == 0:\n    print(\"x es cero\")\nelse:\n    print(\"x es negativo\")"
  },
  {
    "objectID": "posts/Poster/poster.html",
    "href": "posts/Poster/poster.html",
    "title": "Titulo del Poster",
    "section": "",
    "text": "Contexto\nDescriba en 3–5 frases qué pretende mostrar el póster y por qué es relevante. Incluya: - Pregunta guía (¿qué quiere responder la visualización?). - Audiencia (¿a quién va dirigida?). - Decisión/acción esperada (¿qué debería ocurrir después de ver el gráfico?).\n\n\n\nposter.png\n\n\n\n\nDataset\n\nNombre: {{&lt; param dataset_nombre &gt;}}\nFuente (link): Abrir dataset\n\n\n\nDiseño\nEnlace al notebook de las iteraciones: Abrir notebook\nVer Notebook de Iteraciones"
  },
  {
    "objectID": "posts/PlotEcuador/HeatEcuador.html",
    "href": "posts/PlotEcuador/HeatEcuador.html",
    "title": "Ecuador Geo-Visualization: Heatmap by Region",
    "section": "",
    "text": "This project presents an interactive choropleth map of Ecuador using the Folium library, which combines Python with Leaflet.js for dynamic geographic visualizations. The objective is to visually represent region-based intensity data — such as metrics from surveys, socioeconomic indicators, or other analytics — on a province-level map of Ecuador."
  },
  {
    "objectID": "posts/PlotEcuador/HeatEcuador.html#create-synthetic-data-for-plot",
    "href": "posts/PlotEcuador/HeatEcuador.html#create-synthetic-data-for-plot",
    "title": "Ecuador Geo-Visualization: Heatmap by Region",
    "section": "Create Synthetic Data for Plot",
    "text": "Create Synthetic Data for Plot\n\n\ndata = pd.DataFrame({\n    \"intensidad\": np.random.uniform(0, 100, size=24)\n})\ndraw_map(data, \"intensidad\")\n\n&lt;positron-console-cell-19&gt;:35: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/Missigno/missingno.html",
    "href": "posts/Missigno/missingno.html",
    "title": "Gráfico de Datos Faltantes",
    "section": "",
    "text": "Un problema común en los conjuntos de datos es la presencia de valores nulos o faltantes (missing values).\nEstos suelen indicar una deficiencia en la calidad de los datos.La librería Missingno permite identificar de manera rápida dónde se concentran las faltas en cada variable y explorar las posibles correlaciones entre ellas. Permite a los analistas y científicos de datos comprender rápidamente la distribución y el alcance de los valores faltantes en sus datos, lo que les ayuda a tomar decisiones informadas sobre cómo gestionarlos durante el preprocesamiento de datos.\n\nVentajas de Missingno\n\nVisualización sencilla de datos faltantes.\nIdentificación de patrones de datos faltantes y su distribución.\nEn el procesos limpieza y preparación de datos comprender la extensión y la distribución de los datos faltantes es crucial.\nIntegración con Pandas.\n\n\n\nLimitaciones de Missingno\n\nMissingno es útil para visualizar patrones de datos faltantes, pero no incluye métodos de imputación ni análisis estadísticos avanzados.\n\nSu uso está limitado a DataFrames de Pandas y puede presentar problemas de rendimiento en conjuntos de datos muy grandes o con alta proporción de valores nulos.\n\n\n\nInstallación\npip install missingno\n\n::: {#bdeb3e52 .cell execution_count=7}\n``` {.python .cell-code}\npip install missingno\n\nRequirement already satisfied: missingno in c:\\users\\meagu\\anaconda3\\lib\\site-packages (0.5.2)Note: you may need to restart the kernel to use updated packages.\n\nRequirement already satisfied: numpy in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from missingno) (1.26.4)\nRequirement already satisfied: matplotlib in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from missingno) (3.10.0)\nRequirement already satisfied: scipy in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from missingno) (1.13.1)\nRequirement already satisfied: seaborn in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from missingno) (0.13.2)\nRequirement already satisfied: contourpy&gt;=1.0.1 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from matplotlib-&gt;missingno) (1.2.0)\nRequirement already satisfied: cycler&gt;=0.10 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from matplotlib-&gt;missingno) (0.11.0)\nRequirement already satisfied: fonttools&gt;=4.22.0 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from matplotlib-&gt;missingno) (4.51.0)\nRequirement already satisfied: kiwisolver&gt;=1.3.1 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from matplotlib-&gt;missingno) (1.4.4)\nRequirement already satisfied: packaging&gt;=20.0 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from matplotlib-&gt;missingno) (24.1)\nRequirement already satisfied: pillow&gt;=8 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from matplotlib-&gt;missingno) (11.1.0)\nRequirement already satisfied: pyparsing&gt;=2.3.1 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from matplotlib-&gt;missingno) (3.1.2)\nRequirement already satisfied: python-dateutil&gt;=2.7 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from matplotlib-&gt;missingno) (2.9.0.post0)\nRequirement already satisfied: pandas&gt;=1.2 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from seaborn-&gt;missingno) (2.2.3)\nRequirement already satisfied: pytz&gt;=2020.1 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from pandas&gt;=1.2-&gt;seaborn-&gt;missingno) (2024.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from pandas&gt;=1.2-&gt;seaborn-&gt;missingno) (2023.3)\nRequirement already satisfied: six&gt;=1.5 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib-&gt;missingno) (1.16.0)\n\n:::\n\nimport pandas as pd\nimport missingno as msno\nimport matplotlib.pyplot as plt\n\n\n\ndf = pd.read_csv(\"dataset_missing.csv\")\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 120 entries, 0 to 119\nData columns (total 7 columns):\n #   Column       Non-Null Count  Dtype  \n---  ------       --------------  -----  \n 0   id           120 non-null    int64  \n 1   age          96 non-null     float64\n 2   income_usd   108 non-null    float64\n 3   city         98 non-null     object \n 4   signup_date  102 non-null    object \n 5   gender       96 non-null     object \n 6   churned      106 non-null    float64\ndtypes: float64(3), int64(1), object(3)\nmemory usage: 6.7+ KB\n\n\n\n\nGráfico de Matriz de Datos Faltantes\n\n\nmsno.matrix(df)\n\n\n\n\n\n\n\n\n\n\nGráfico de barras de Datos Faltantes\n\nmsno.bar(df)\n\n\n\n\n\n\n\n\n\n\nHeatmap correlacional de Datos Faltantes\n\nmsno.heatmap(df)\n\n\n\n\n\n\n\n\n\n\nRealiza un diagnóstico de datos faltantes con missingno\n\nSelecciona un dataset que contenga valores faltantes (NA).\n\nIdentifica y cuantifica los patrones de datos faltantes en el dataset.\n\nCompara diferentes visualizaciones de datos ausentes utilizando la librería missingno:\n\nmatrix\n\nbar\n\nheatmap\n\ndendrogram (investiga qué es y para qué se utiliza)"
  },
  {
    "objectID": "posts/mapaCalorF/folium_heatmap.html",
    "href": "posts/mapaCalorF/folium_heatmap.html",
    "title": "Heatmap folium",
    "section": "",
    "text": "Un heatmap o mapa de calor es una visualización que utiliza una escala de colores para representar la intensidad o concentración de un fenómeno sobre una superficie. Su objetivo es revelar patrones espaciales de forma rápida e intuitiva.\nA diferencia de los mapas coropléticos, que colorean regiones administrativas (provincias, cantones, países), el heatmap utiliza puntos geográficos individuales (latitud y longitud) y genera zonas más claras u oscuras según la densidad de datos (hotspots)."
  },
  {
    "objectID": "posts/mapaCalorF/folium_heatmap.html#buenas-prácticas-y-errores-comunes",
    "href": "posts/mapaCalorF/folium_heatmap.html#buenas-prácticas-y-errores-comunes",
    "title": "Heatmap folium",
    "section": "Buenas prácticas y errores comunes",
    "text": "Buenas prácticas y errores comunes\n\nAjustar radio y blur para una visualización adecuada.\nUsar colores progresivos y claros.\nIncluir leyenda si es posible.\nNormalizar datos si los puntos tienen distinto peso o importancia.\nUsar pocos datos → mapa sin patrones reales.\nInterpretar el heatmap como un valor exacto por región.\nNo ajustar los parámetros → manchas confusas o invisibles.\nColores mal seleccionados que dificultan la lectura."
  },
  {
    "objectID": "posts/mapaCalorF/folium_heatmap.html#linea-de-tiempo",
    "href": "posts/mapaCalorF/folium_heatmap.html#linea-de-tiempo",
    "title": "Heatmap folium",
    "section": "Linea de tiempo",
    "text": "Linea de tiempo\n\ndfmap=df[df[\"EVENTO\"]==\"Inundacion\"]\ndfmap = dfmap[[\"latitud\",\"longitud\",\"EVENTO\",'AÑO', 'MES', 'DIA']]\n\ndfmap = dfmap.rename(columns=lambda x: x.strip())\n\n# Crear la columna FECHA como texto: 'YYYY-MM-DD'\ndfmap['FECHA'] = (\n    dfmap['AÑO'].astype(int).astype(str) + '-' +\n    dfmap['MES'].astype(int).astype(str).str.zfill(2) + '-' +\n    dfmap['DIA'].astype(int).astype(str).str.zfill(2)\n)\ndfmap = dfmap.dropna(subset=['FECHA'])\ndfmap.head()\n\n\n\n\n\n\n\n\nlatitud\nlongitud\nEVENTO\nAÑO\nMES\nDIA\nFECHA\n\n\n\n\n0\n-0.21665\n-78.50222\nInundacion\n1900\n3\n21\n1900-03-21\n\n\n1\n-0.22154\n-78.51142\nInundacion\n1900\n5\n19\n1900-05-19\n\n\n2\n-0.22003\n-78.51588\nInundacion\n1902\n3\n19\n1902-03-19\n\n\n9\n-0.22329\n-78.51295\nInundacion\n1909\n3\n7\n1909-03-07\n\n\n12\n-0.22048\n-78.51566\nInundacion\n1911\n1\n26\n1911-01-26\n\n\n\n\n\n\n\n\n# Lista de fechas\ndfmap['FECHA'] = pd.to_datetime(dfmap['FECHA'], errors='coerce')\n\n# 3️⃣ Eliminar fechas inválidas\ndfmap = dfmap.dropna(subset=['FECHA'])\n\n# 4️⃣ Ahora sí, crear time_index correctamente\ntime_index = sorted(dfmap['FECHA'].dt.strftime('%Y-%m-%d').unique())\n\n# Lista \ndata = []\n\nfor fecha in time_index:\n    sub = dfmap[dfmap['FECHA'] == fecha]\n    puntos = sub[['latitud', 'longitud']].values.tolist()\n    data.append(puntos)\n\n\n# puntos exactos en el mapa \"latitud\",\"longitud\"\n# Mapa base centrado en Ecuador\nm = folium.Map(\n    [-0.19899731681836336, -78.4428000494774], # PUNTO INICIAL\n    zoom_start=10)\n    \nHeatMapWithTime(\n    data=data,\n    index=time_index,\n    auto_play=True,\n    radius=20,\n    max_opacity=0.6\n).add_to(m)\n\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/Lollipop/Lollipop.html",
    "href": "posts/Lollipop/Lollipop.html",
    "title": "Lollipop",
    "section": "",
    "text": "Un gráfico de piruleta (Lollipop chart) es una variación del gráfico de barras en el que cada barra se sustituye por una línea delgada que termina en un punto. Al igual que el gráfico de barras, permite mostrar la relación entre una variable categórica y una numérica, pero con una apariencia más ligera y atractiva. Su simplicidad visual ayuda a evitar la sobrecarga gráfica cuando existen muchas categorías o valores muy similares.\nEste tipo de gráfico resulta especialmente útil cuando se busca destacar diferencias sutiles entre categorías o cuando varias tienen valores cercanos, reduciendo el “efecto Moiré” que puede aparecer en un barplot clásico.\nPara mejorar su claridad, conviene:\n- Ordenar los grupos (idealmente de mayor a menor si no existe un orden natural).\n- Usar la versión horizontal cuando las etiquetas son extensas, para mejorar la lectura.\n- Resaltar los puntos con colores adecuados que faciliten la comparación.\n- Usarlo cuando solo se represente un valor por categoría, sin subgrupos múltiples.\n\nErrores habituales:\n\nNo ordenar las categorías: dificulta la lectura y comprensión.\n\nUsarlo con varios valores por grupo: en ese caso es preferible un boxplot o violin plot.\n\nMantener los datos sin orden natural en lollipop puede confundir: en esas situaciones un barplot es más claro.\n\nForzar el uso cuando se necesita mostrar distribuciones completas; el lollipop solo muestra un valor central.\n\n\n\nDataset: Precios Agroindustria de Cacao (2012 - 2025)\nArchivo: MAG_PreciosAgroindustriaCacao_2025Junio.csv\nFuente: Ministerio de Agricultura y Ganadería (MAG), Ecuador\nÚltima actualización: Junio 2025\n\nimport pandas as pd\ndf = pd.read_csv(\"mag_preciosagroindustriacacao_2025junio.csv\", sep=\";\")\nprint(df.head())\nprint(df.info())\n\n   PACC_ANIO PACC_MES DPA_PROVINCIA DPA_CANTON        PACC_PRODUCTO  \\\n0       2012    Enero        El Oro  Arenillas  Cacao seco mezclado   \n1       2012    Enero        El Oro  Arenillas  Cacao seco mezclado   \n2       2012    Enero        El Oro   El Guabo  Cacao seco mezclado   \n3       2012    Enero        El Oro   El Guabo  Cacao seco mezclado   \n4       2012    Enero        El Oro    Machala  Cacao seco mezclado   \n\n          PACC_PRESENTACION PACC_TIPO  PACC_PRECIO_USD  PACC_USD_KG  \n0  Quintal de 100,00 libras    Compra            71.41         1.57  \n1  Quintal de 100,00 libras     Venta            74.06         1.63  \n2  Quintal de 100,00 libras    Compra            73.75         1.63  \n3  Quintal de 100,00 libras     Venta            84.00         1.85  \n4  Quintal de 100,00 libras    Compra            75.00         1.65  \n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 26246 entries, 0 to 26245\nData columns (total 9 columns):\n #   Column             Non-Null Count  Dtype  \n---  ------             --------------  -----  \n 0   PACC_ANIO          26246 non-null  int64  \n 1   PACC_MES           26246 non-null  object \n 2   DPA_PROVINCIA      26246 non-null  object \n 3   DPA_CANTON         26246 non-null  object \n 4   PACC_PRODUCTO      26246 non-null  object \n 5   PACC_PRESENTACION  26246 non-null  object \n 6   PACC_TIPO          26246 non-null  object \n 7   PACC_PRECIO_USD    26246 non-null  float64\n 8   PACC_USD_KG        26246 non-null  float64\ndtypes: float64(2), int64(1), object(6)\nmemory usage: 1.8+ MB\nNone\n\n\n\nimport plotly.graph_objects as go\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\n\nimport matplotlib.pyplot as plt\n\n# Agrupar para obtener el precio promedio por año\ndf_avg_anio = df.groupby(\"PACC_ANIO\", as_index=False)[\"PACC_PRECIO_USD\"].mean()\n\n# Datos\nx = df_avg_anio[\"PACC_ANIO\"]\ny = df_avg_anio[\"PACC_PRECIO_USD\"]\n\n# Crear figura\nplt.figure(figsize=(10, 6))\n\n# Dibujar líneas desde 0 hasta cada valor (tallo del lollipop)\nfor i in range(len(x)):\n    plt.plot([x[i], x[i]], [0, y[i]], color=\"darkblue\", linewidth=2)\n    plt.scatter(x[i], y[i], \n                c=y[i], cmap=\"viridis\", \n                s=120, edgecolor=\"black\", zorder=3)\n\n    # Texto encima de cada punto\n    plt.text(x[i], y[i] + 0.5, f\"{y[i]:.2f}\", \n             ha=\"center\", va=\"bottom\", fontsize=10)\n\n# Estilo general\nplt.title(\"Precio promedio en USD por año (Lollipop Chart)\", fontsize=16, color=\"darkblue\")\nplt.xlabel(\"Año\")\nplt.ylabel(\"Precio USD\")\nplt.grid(axis=\"y\", linestyle=\"--\", alpha=0.6)\nplt.gca().set_facecolor(\"white\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\n\ndef plotly_lollipop(signal, orientation=\"vertical\",\n                    marker_color=\"red\", line_color=\"grey\",\n                    marker_offset=0.04, title=\"Lollipop Chart\"):\n    \"\"\"\n    Genera un gráfico tipo Lollipop (vertical u horizontal) con Plotly.\n\n    Parámetros\n    ----------\n    signal : list, np.array o pd.Series\n        Señal de valores numéricos a graficar.\n    orientation : str\n        'vertical' para palitos en eje Y (default), 'horizontal' para palitos en eje X.\n    marker_color : str\n        Color de los puntos (default = 'red').\n    line_color : str\n        Color de las líneas (default = 'grey').\n    marker_offset : float\n        Margen de separación entre la línea y el punto para evitar superposición.\n    title : str\n        Título del gráfico.\n    \"\"\"\n\n    def offset_signal(val, marker_offset):\n        if abs(val) &lt;= marker_offset:\n            return 0\n        return val - marker_offset if val &gt; 0 else val + marker_offset\n\n    n = len(signal)\n\n    # Puntos\n    if orientation == \"vertical\":\n        data = [go.Scatter(\n            x=list(range(n)),\n            y=signal,\n            mode=\"markers\",\n            marker=dict(color=marker_color, size=8)\n        )]\n        shapes = [dict(\n            type=\"line\",\n            xref=\"x\",\n            yref=\"y\",\n            x0=i, y0=0,\n            x1=i, y1=offset_signal(signal[i], marker_offset),\n            line=dict(color=line_color, width=1)\n        ) for i in range(n)]\n\n    elif orientation == \"horizontal\":\n        data = [go.Scatter(\n            x=signal,\n            y=list(range(n)),\n            mode=\"markers\",\n            marker=dict(color=marker_color, size=8)\n        )]\n        shapes = [dict(\n            type=\"line\",\n            xref=\"x\",\n            yref=\"y\",\n            x0=0, y0=i,\n            x1=offset_signal(signal[i], marker_offset), y1=i,\n            line=dict(color=line_color, width=1)\n        ) for i in range(n)]\n\n    else:\n        raise ValueError(\"orientation debe ser 'vertical' o 'horizontal'\")\n\n    # Layout\n    layout = go.Layout(shapes=shapes, title=title)\n    fig = go.Figure(data=data, layout=layout)\n    pyo.iplot(fig)\n    return fig\n\n\n# Ejemplo de uso\nif __name__ == \"__main__\":\n    np.random.seed(42)\n    random_signal = np.random.normal(size=20)\n\n    # Vertical\n    plotly_lollipop(random_signal, orientation=\"vertical\", marker_color=\"blue\", line_color=\"black\", title=\"Lollipop Vertical\")\n\n    # Horizontal\n    plotly_lollipop(random_signal, orientation=\"horizontal\", marker_color=\"green\", line_color=\"black\", title=\"Lollipop Horizontal\")\n\n                                                \n\n\n                                                \n\n\n\n# Create a dataframe\nimport pandas as pd\ndf = pd.DataFrame({'group':list(map(chr, range(65, 85))), 'values':np.random.uniform(size=20) })\n\n# Reorder it following the values:\nordered_df = df.sort_values(by='values')\nmy_range=range(1,len(df.index)+1)\n\n# Make the plot\nplt.stem(ordered_df['values'])\nplt.xticks( my_range, ordered_df['group'])\n\n([&lt;matplotlib.axis.XTick at 0x15d4fdace00&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fdad4c0&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fdacb60&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fd95fd0&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fd95ee0&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fcbb800&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fcba180&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fd94620&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fcb8650&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fcb9c40&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fcbb8f0&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fcbb950&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fcbaf00&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fc35340&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fc341d0&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fc36000&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fc37200&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fc35520&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fc375c0&gt;,\n  &lt;matplotlib.axis.XTick at 0x15d4fd00ef0&gt;],\n [Text(1, 0, 'S'),\n  Text(2, 0, 'F'),\n  Text(3, 0, 'I'),\n  Text(4, 0, 'N'),\n  Text(5, 0, 'Q'),\n  Text(6, 0, 'H'),\n  Text(7, 0, 'C'),\n  Text(8, 0, 'M'),\n  Text(9, 0, 'P'),\n  Text(10, 0, 'A'),\n  Text(11, 0, 'R'),\n  Text(12, 0, 'D'),\n  Text(13, 0, 'E'),\n  Text(14, 0, 'G'),\n  Text(15, 0, 'O'),\n  Text(16, 0, 'B'),\n  Text(17, 0, 'L'),\n  Text(18, 0, 'T'),\n  Text(19, 0, 'J'),\n  Text(20, 0, 'K')])\n\n\n\n\n\n\n\n\n\n\n# --- Usamos la función definida antes ---\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\n\ndef plotly_lollipop(x, y, orientation=\"vertical\",\n                    marker_color=\"red\", line_color=\"grey\",\n                    marker_offset=0.04, title=\"Lollipop Chart\"):\n    \"\"\"\n    Genera un gráfico tipo Lollipop (vertical u horizontal) con Plotly.\n    \"\"\"\n    def offset_signal(val, marker_offset):\n        if abs(val) &lt;= marker_offset:\n            return 0\n        return val - marker_offset if val &gt; 0 else val + marker_offset\n\n    n = len(y)\n\n    if orientation == \"vertical\":\n        data = [go.Scatter(\n            x=x,\n            y=y,\n            mode=\"markers\",\n            marker=dict(color=marker_color, size=8)\n        )]\n        shapes = [dict(\n            type=\"line\",\n            xref=\"x\",\n            yref=\"y\",\n            x0=x[i], y0=0,\n            x1=x[i], y1=offset_signal(y[i], marker_offset),\n            line=dict(color=line_color, width=1)\n        ) for i in range(n)]\n\n    elif orientation == \"horizontal\":\n        data = [go.Scatter(\n            x=y,\n            y=x,\n            mode=\"markers\",\n            marker=dict(color=marker_color, size=8)\n        )]\n        shapes = [dict(\n            type=\"line\",\n            xref=\"x\",\n            yref=\"y\",\n            x0=0, y0=x[i],\n            x1=offset_signal(y[i], marker_offset), y1=x[i],\n            line=dict(color=line_color, width=1)\n        ) for i in range(n)]\n\n    else:\n        raise ValueError(\"orientation debe ser 'vertical' o 'horizontal'\")\n\n    layout = go.Layout(\n        shapes=shapes,\n        title=title,\n        xaxis=dict(title=\"Año\" if orientation==\"vertical\" else \"Precio USD\"),\n        yaxis=dict(title=\"Precio USD\" if orientation==\"vertical\" else \"Año\")\n    )\n\n    fig = go.Figure(data=data, layout=layout)\n    pyo.iplot(fig)\n    return fig\n\n\n# --- Aplicación a tu dataset ---\nx = df_avg_anio[\"PACC_ANIO\"]\ny = df_avg_anio[\"PACC_PRECIO_USD\"]\n\n# Vertical\nplotly_lollipop(x, y, orientation=\"vertical\", marker_color=\"blue\", line_color=\"black\", title=\"Precio promedio en USD por año\")\n\n# Horizontal (opcional)\n# plotly_lollipop(x, y, orientation=\"horizontal\", marker_color=\"green\", line_color=\"black\", title=\"Precio promedio en USD por año (horizontal)\")"
  },
  {
    "objectID": "posts/introPandas/Intro_a_Pandas.html",
    "href": "posts/introPandas/Intro_a_Pandas.html",
    "title": "Introducción a Pandas",
    "section": "",
    "text": "En este cuaderno veremos los elementos y funciones básicas de la librería Pandas. Los contenidos específicos son:"
  },
  {
    "objectID": "posts/introPandas/Intro_a_Pandas.html#qué-es-pandas",
    "href": "posts/introPandas/Intro_a_Pandas.html#qué-es-pandas",
    "title": "Introducción a Pandas",
    "section": "1 ¿Qué es Pandas?",
    "text": "1 ¿Qué es Pandas?\n\n\n\nPandas es una librería de Python con la que puedes trabajar con datos tabulados. Es muy útil para limpiar, analizar y procesar datos.\nDe acuerdo con Wikipedia: “(…) extensión de NumPy para manipulación y análisis de datos para el lenguaje de programación Python. En particular, ofrece estructuras de datos y operaciones para manipular tablas numéricas y series temporales.”\n\n#immportacion modulos\nimport pandas as pd\nimport numpy as np"
  },
  {
    "objectID": "posts/introPandas/Intro_a_Pandas.html#dónde-encontrar-datos",
    "href": "posts/introPandas/Intro_a_Pandas.html#dónde-encontrar-datos",
    "title": "Introducción a Pandas",
    "section": "2 ¿Dónde encontrar datos?",
    "text": "2 ¿Dónde encontrar datos?\nEn internet existen repositorios de datos abiertos de los que puedes descargar datasets. Algunos ejemplos:\n\nKaggle: Sitio web para prácticar y aprender sobre ciencia de datos y machine learning.\nUC Irvine Machine Learning Repository: En este repositorio hay más de 500 datasets de diversos temas. Usualmente son útiles para practicar y aprender sobre machine learning.\nCatálogo de Datos Abiertos Datos abiertos del Ecuador. . . .\n\nExiste una gran cantidad de datasets disponibles con los que puedes trabajar."
  },
  {
    "objectID": "posts/introPandas/Intro_a_Pandas.html#carga-de-datos.",
    "href": "posts/introPandas/Intro_a_Pandas.html#carga-de-datos.",
    "title": "Introducción a Pandas",
    "section": "3 Carga de Datos.",
    "text": "3 Carga de Datos.\nCon Pandas puedes cargar datos de archivos externos. por lo general son datos tabulados. Los más comunes son archivos CSV, xlsx (Excel).\n\n# Para importar un archivo csv\ndatos = pd.read_csv('dataset.csv' , sep=\";\")\n\nC:\\Users\\meagu\\AppData\\Local\\Temp\\ipykernel_25952\\3482028259.py:2: DtypeWarning: Columns (5,7) have mixed types. Specify dtype option on import or set low_memory=False.\n  datos = pd.read_csv('dataset.csv' , sep=\";\")\n\n\n\ndatos.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 50545 entries, 0 to 50544\nData columns (total 78 columns):\n #   Column                    Non-Null Count  Dtype \n---  ------                    --------------  ----- \n 0   ciclo                     50545 non-null  object\n 1   grado                     50545 non-null  int64 \n 2   estado_eval               50545 non-null  int64 \n 3   codigo                    50545 non-null  object\n 4   amie                      50545 non-null  object\n 5   nm_regi                   50545 non-null  object\n 6   es_regeva                 50545 non-null  int64 \n 7   id_zona                   50545 non-null  object\n 8   id_dist                   50545 non-null  object\n 9   id_prov                   50545 non-null  int64 \n 10  id_cant                   50545 non-null  int64 \n 11  id_parr                   50545 non-null  int64 \n 12  financiamiento            50545 non-null  int64 \n 13  sostenimiento             50545 non-null  int64 \n 14  tp_sexo                   50545 non-null  int64 \n 15  na_eano                   50545 non-null  int64 \n 16  tp_area                   50545 non-null  int64 \n 17  etnibee                   50545 non-null  object\n 18  isec                      50545 non-null  object\n 19  quintil                   50545 non-null  object\n 20  fex_inev                  50545 non-null  object\n 21  inev                      50545 non-null  object\n 22  fex_imat                  50545 non-null  object\n 23  imat                      50545 non-null  object\n 24  fex_ilyl                  50545 non-null  object\n 25  ilyl                      50545 non-null  object\n 26  fex_icn                   50545 non-null  object\n 27  icn                       50545 non-null  object\n 28  fex_ifis                  50545 non-null  object\n 29  ifis                      50545 non-null  object\n 30  fex_iqui                  50545 non-null  object\n 31  iqui                      50545 non-null  object\n 32  fex_ibio                  50545 non-null  object\n 33  ibio                      50545 non-null  object\n 34  fex_ies                   50545 non-null  object\n 35  ies                       50545 non-null  object\n 36  fex_ihis                  50545 non-null  object\n 37  ihis                      50545 non-null  object\n 38  fex_ifil                  50545 non-null  object\n 39  ifil                      50545 non-null  object\n 40  fex_ied                   50545 non-null  object\n 41  ied                       50545 non-null  object\n 42  nl_imat                   50545 non-null  object\n 43  nl_ilyl                   50545 non-null  object\n 44  nl_icn                    50545 non-null  object\n 45  nl_ifis                   50545 non-null  object\n 46  nl_iqui                   50545 non-null  object\n 47  nl_ibio                   50545 non-null  object\n 48  nl_ies                    50545 non-null  object\n 49  nl_ihis                   50545 non-null  object\n 50  nl_ifil                   50545 non-null  object\n 51  nl_ied                    50545 non-null  object\n 52  ind_1                     50545 non-null  object\n 53  ind_2                     50545 non-null  object\n 54  ind_3                     50545 non-null  object\n 55  ind_4                     50545 non-null  object\n 56  ind_5                     50545 non-null  object\n 57  ind_6                     50545 non-null  object\n 58  ind_7                     50545 non-null  object\n 59  ind_8                     50545 non-null  object\n 60  ind_9                     50545 non-null  object\n 61  lc_1                      50545 non-null  object\n 62  lc_2                      50545 non-null  object\n 63  lc_3                      50545 non-null  object\n 64  lc_4                      50545 non-null  object\n 65  lc_5                      50545 non-null  object\n 66  lc_6                      50545 non-null  object\n 67  lc_7                      50545 non-null  object\n 68  lc_8                      50545 non-null  object\n 69  lc_9                      50545 non-null  object\n 70  lc_10                     50545 non-null  object\n 71  lc_11                     50545 non-null  object\n 72  lc_12                     50545 non-null  object\n 73  fex_rubrica               50545 non-null  object\n 74  estado_rub                50545 non-null  object\n 75  fex_lista_cotejo          50545 non-null  object\n 76  estado_lc                 50545 non-null  object\n 77  fex_honestidad_academica  50545 non-null  object\ndtypes: int64(11), object(67)\nmemory usage: 30.1+ MB\n\n\n\ndatos.to_excel(\"excel.xlsx\")\n\n\n# Para importar un archivo de excel\ndatos_excel = pd.read_excel('excel.xlsx')\n\n\n# Importamos un archivo \ndatos = pd.read_csv('dataset.csv' , sep=\";\")\n# Podemos ver el inicio de un DataFrame con .head()\ndatos.columns\n\nC:\\Users\\meagu\\AppData\\Local\\Temp\\ipykernel_25952\\1594173510.py:2: DtypeWarning: Columns (5,7) have mixed types. Specify dtype option on import or set low_memory=False.\n  datos = pd.read_csv('dataset.csv' , sep=\";\")\n\n\nIndex(['ciclo', 'grado', 'estado_eval', 'codigo', 'amie', 'nm_regi',\n       'es_regeva', 'id_zona', 'id_dist', 'id_prov', 'id_cant', 'id_parr',\n       'financiamiento', 'sostenimiento', 'tp_sexo', 'na_eano', 'tp_area',\n       'etnibee', 'isec', 'quintil', 'fex_inev', 'inev', 'fex_imat', 'imat',\n       'fex_ilyl', 'ilyl', 'fex_icn', 'icn', 'fex_ifis', 'ifis', 'fex_iqui',\n       'iqui', 'fex_ibio', 'ibio', 'fex_ies', 'ies', 'fex_ihis', 'ihis',\n       'fex_ifil', 'ifil', 'fex_ied', 'ied', 'nl_imat', 'nl_ilyl', 'nl_icn',\n       'nl_ifis', 'nl_iqui', 'nl_ibio', 'nl_ies', 'nl_ihis', 'nl_ifil',\n       'nl_ied', 'ind_1', 'ind_2', 'ind_3', 'ind_4', 'ind_5', 'ind_6', 'ind_7',\n       'ind_8', 'ind_9', 'lc_1', 'lc_2', 'lc_3', 'lc_4', 'lc_5', 'lc_6',\n       'lc_7', 'lc_8', 'lc_9', 'lc_10', 'lc_11', 'lc_12', 'fex_rubrica',\n       'estado_rub', 'fex_lista_cotejo', 'estado_lc',\n       'fex_honestidad_academica'],\n      dtype='object')"
  },
  {
    "objectID": "posts/introPandas/Intro_a_Pandas.html#dataframes.",
    "href": "posts/introPandas/Intro_a_Pandas.html#dataframes.",
    "title": "Introducción a Pandas",
    "section": "4 DataFrames.",
    "text": "4 DataFrames.\nComo ya mencionamos, una Series se puede entender como una tabla con una sola columna, aunque también puedes verla como una lista donde cada elemento tiene una etiqueta, un índice el cual por default es un número entero de la posición del elemento.\n\n\n\nPara crear una serie partiendo de una lista:\n\nserie = pd.Series(['caracteres', 3.1416, True])\n\n# Imprimimos la serie que creamos\nprint(serie)\n\n# Información de la serie\nprint(\"\\nTipo de dato: \", type(serie))\nprint(\"Tamaño: \", serie.size)\n\n0    caracteres\n1        3.1416\n2          True\ndtype: object\n\nTipo de dato:  &lt;class 'pandas.core.series.Series'&gt;\nTamaño:  3\n\n\nObservamos cómo cada elemento de la lista ahora tiene un índice. Podemos especificar el índice explícitamente:\n\nserie = pd.Series(data = ['caracteres', 3.1416, True],\n                  index = ['1', '2', '3'])\n\nprint(serie)\n\n# Podemos obtener un elemento con su índice\nprint(serie['Elemento 1'])\n\nElemento 1    caracteres\nElemento 2        3.1416\nElemento 2          True\ndtype: object\ncaracteres\n\n\nLos DataFrames son más complejos que las Series, ya que ahora tenemos una tabla con varias columnas. En este caso, tendremos índices para cada fila y también etiquetas para las columnas. Los valores default son también enteros que indican la posición.\n\n\n\n\n# Creemos DataFrame con una matriz aleatoria.\ndf = pd.DataFrame(data = np.random.rand(4, 4))\n\nprint(\"Tipo: \", type(df)) # Tipo de objeto\nprint(\"Tamaño: \", df.size)  #El tamaño es igual al número de celdas\nprint(\"Tamaño: \", df.info())\ndf # Visualizamos el DataFrame completo\n\nTipo:  &lt;class 'pandas.core.frame.DataFrame'&gt;\nTamaño:  16\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 4 entries, 0 to 3\nData columns (total 4 columns):\n #   Column  Non-Null Count  Dtype  \n---  ------  --------------  -----  \n 0   0       4 non-null      float64\n 1   1       4 non-null      float64\n 2   2       4 non-null      float64\n 3   3       4 non-null      float64\ndtypes: float64(4)\nmemory usage: 260.0 bytes\nTamaño:  None\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n0\n0.313387\n0.897866\n0.445509\n0.413369\n\n\n1\n0.584700\n0.398930\n0.613012\n0.103134\n\n\n2\n0.201942\n0.184334\n0.419727\n0.610008\n\n\n3\n0.673399\n0.149493\n0.660942\n0.542672\n\n\n\n\n\n\n\n\n# Podemos crear DataFrames a partir de diccionarios \ndf_dict = pd.DataFrame({\n    'Nombre':['Marco', 'Esteban', 'Antonio'],\n    'Edad':[32, 40, 1534],\n    'Altura':[1.82, 1.60, 1.50],},\n    index = ['Persona 1', 'Persona 2', 'Persona 3']) # Especificamos índice\ndf_dict\n\n\n\n\n\n\n\n\nNombre\nEdad\nAltura\n\n\n\n\nPersona 1\nMarco\n32\n1.82\n\n\nPersona 2\nEsteban\n40\n1.60\n\n\nPersona 3\nAntonio\n1534\n1.50\n\n\n\n\n\n\n\nEjercicio: - Crea un DataFrame con una matriz de unos con dimensión (4, 3) - Asigna números enteros pares como índice. - Asigna letras como columnas.\n\n#\nda = [1,1,1]\n#ky = { for x in []}\ndf_dict = pd.DataFrame({\n    'a':[1,1,1],\n    'b':da,\n    'c':da,\n    'd':da,\n    },\n    index = [2,4,6]) # Especificamos índice\ndf_dict\n\n\n\n\n\n\n\n\na\nb\nc\nd\n\n\n\n\n2\n1\n1\n1\n1\n\n\n4\n1\n1\n1\n1\n\n\n6\n1\n1\n1\n1"
  },
  {
    "objectID": "posts/introPandas/Intro_a_Pandas.html#revisando-los-datos.",
    "href": "posts/introPandas/Intro_a_Pandas.html#revisando-los-datos.",
    "title": "Introducción a Pandas",
    "section": "5 Revisando los datos.",
    "text": "5 Revisando los datos.\nPara visualizar los datos de un DataFrame, tenemos dos opciones:\n# Mostramos las primeras 7 filas.\ndf.head(n = 7)\n\n# Mostramos las últimas 4 filas.\ndf.tail(n = 4)\nSi queremos ver un DataFrame completo, lo ponemos solo en una celda.\n# Para ver todo el DataFrame\ndf\n\ndata = pd.read_csv(\"dataset.csv\" , sep=\";\")\n\nC:\\Users\\meagu\\AppData\\Local\\Temp\\ipykernel_25952\\1555053127.py:1: DtypeWarning: Columns (5,7) have mixed types. Specify dtype option on import or set low_memory=False.\n  data = pd.read_csv(\"dataset.csv\" , sep=\";\")\n\n\n\ndata.head(n = 3)\n\n\n\n\n\n\n\n\nciclo\ngrado\nestado_eval\ncodigo\namie\nnm_regi\nes_regeva\nid_zona\nid_dist\nid_prov\n...\nlc_8\nlc_9\nlc_10\nlc_11\nlc_12\nfex_rubrica\nestado_rub\nfex_lista_cotejo\nestado_lc\nfex_honestidad_academica\n\n\n\n\n0\n2023-2024\n10\n2\n0BY3566978\n01H00655\n2\n1\n6\n01D02\n1\n...\n\n\n\n\n\n24,31269711\n2\n\n2\n20,73730047\n\n\n1\n2023-2024\n10\n2\n0EYB576428\n01H00655\n2\n1\n6\n01D02\n1\n...\n\n\n\n\n\n24,31269711\n2\n\n2\n20,73730047\n\n\n2\n2023-2024\n10\n2\n0LXC578175\n01H00655\n2\n1\n6\n01D02\n1\n...\n\n\n\n\n\n24,31269711\n2\n\n2\n20,73730047\n\n\n\n\n3 rows × 78 columns\n\n\n\n\ndata.tail(n = 4)\n\n\n\n\n\n\n\n\nciclo\ngrado\nestado_eval\ncodigo\namie\nnm_regi\nes_regeva\nid_zona\nid_dist\nid_prov\n...\nlc_8\nlc_9\nlc_10\nlc_11\nlc_12\nfex_rubrica\nestado_rub\nfex_lista_cotejo\nestado_lc\nfex_honestidad_academica\n\n\n\n\n50541\n2023-2024\n4\n2\nLQZJ544557\n22H00530\n3\n2\n2\n22D02\n22\n...\n0\n0\n0\n0\n0\n19,12987428\n2\n15,30389943\n2\n\n\n\n50542\n2023-2024\n4\n2\nP33E565302\n22H00530\n3\n2\n2\n22D02\n22\n...\n0\n0\n0\n0\n0\n19,12987428\n2\n15,30389943\n2\n\n\n\n50543\n2023-2024\n4\n2\nPLBA561287\n22H00530\n3\n2\n2\n22D02\n22\n...\n0\n0\n0\n0\n0\n19,12987428\n2\n15,30389943\n2\n\n\n\n50544\n2023-2024\n4\n2\nPS7V552528\n22H00530\n3\n2\n2\n22D02\n22\n...\n0\n0\n0\n0\n0\n19,12987428\n2\n15,30389943\n2\n\n\n\n\n\n4 rows × 78 columns\n\n\n\nAdemás de consultar partes del DataFrame, también podemos consultar las etiquetas en las filas y las columnas, así como todos los valores del DataFrame.\ndf = data\ncolumnas = df.columns  # Obtenemos columnas\nindice = df.index  # Obtenemos filas\nvalores = df.values  # Obtenemos valores\nVeamos un ejemplo de esto:\n\ncolumnas = df_dict.columns\nfilas = df_dict.index\nvalores = df_dict.values\n\nprint('Columnas: ', columnas, '\\nFilas: ', filas)\nprint(valores, type(valores))  # Los valores son una matriz de NumPy!!\n\ndf_dict   # Recordamos el DataFrame de donde obtenemos estos valores\n\nColumnas:  Index(['a', 'b', 'c', 'd'], dtype='object') \nFilas:  Index([2, 4, 6], dtype='int64')\n[[1 1 1 1]\n [1 1 1 1]\n [1 1 1 1]] &lt;class 'numpy.ndarray'&gt;\n\n\n\n\n\n\n\n\n\na\nb\nc\nd\n\n\n\n\n2\n1\n1\n1\n1\n\n\n4\n1\n1\n1\n1\n\n\n6\n1\n1\n1\n1\n\n\n\n\n\n\n\nFinalmente, cuando tenemos un conjunto de datos, nos será útil hacer un análisis inicial (exploratorio) de los datos.\n# Describimos en general el DataFrame\ndf.describe()\nPor ejemplo, obtenemos una descripción del DataFrame de la densidad poblacional:\n\n   # Recordamos el DataFrame de donde obtenemos estos valores\ndata.describe()\n\n\n\n\n\n\n\n\ngrado\nestado_eval\nes_regeva\nid_prov\nid_cant\nid_parr\nfinanciamiento\nsostenimiento\ntp_sexo\nna_eano\ntp_area\n\n\n\n\ncount\n50545.000000\n50545.000000\n50545.000000\n50545.000000\n50545.000000\n50545.000000\n50545.000000\n50545.000000\n50545.000000\n50545.000000\n50545.000000\n\n\nmean\n6.034781\n1.969275\n1.514255\n12.869720\n1290.180552\n129050.093303\n1.704541\n2.758987\n1.501316\n2010.339717\n1.644653\n\n\nstd\n2.728360\n0.172574\n0.499802\n7.191719\n718.664646\n71870.803082\n0.805489\n1.230177\n0.500003\n3.325834\n0.478623\n\n\nmin\n3.000000\n1.000000\n1.000000\n1.000000\n101.000000\n10101.000000\n1.000000\n1.000000\n1.000000\n2000.000000\n1.000000\n\n\n25%\n4.000000\n2.000000\n1.000000\n9.000000\n901.000000\n90112.000000\n1.000000\n1.000000\n1.000000\n2008.000000\n1.000000\n\n\n50%\n7.000000\n2.000000\n2.000000\n12.000000\n1213.000000\n121350.000000\n1.000000\n3.000000\n2.000000\n2011.000000\n2.000000\n\n\n75%\n10.000000\n2.000000\n2.000000\n17.000000\n1701.000000\n170155.000000\n2.000000\n4.000000\n2.000000\n2013.000000\n2.000000\n\n\nmax\n10.000000\n2.000000\n2.000000\n90.000000\n9004.000000\n900451.000000\n3.000000\n4.000000\n2.000000\n2016.000000\n2.000000\n\n\n\n\n\n\n\n\ndata.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 50545 entries, 0 to 50544\nData columns (total 78 columns):\n #   Column                    Non-Null Count  Dtype \n---  ------                    --------------  ----- \n 0   ciclo                     50545 non-null  object\n 1   grado                     50545 non-null  int64 \n 2   estado_eval               50545 non-null  int64 \n 3   codigo                    50545 non-null  object\n 4   amie                      50545 non-null  object\n 5   nm_regi                   50545 non-null  object\n 6   es_regeva                 50545 non-null  int64 \n 7   id_zona                   50545 non-null  object\n 8   id_dist                   50545 non-null  object\n 9   id_prov                   50545 non-null  int64 \n 10  id_cant                   50545 non-null  int64 \n 11  id_parr                   50545 non-null  int64 \n 12  financiamiento            50545 non-null  int64 \n 13  sostenimiento             50545 non-null  int64 \n 14  tp_sexo                   50545 non-null  int64 \n 15  na_eano                   50545 non-null  int64 \n 16  tp_area                   50545 non-null  int64 \n 17  etnibee                   50545 non-null  object\n 18  isec                      50545 non-null  object\n 19  quintil                   50545 non-null  object\n 20  fex_inev                  50545 non-null  object\n 21  inev                      50545 non-null  object\n 22  fex_imat                  50545 non-null  object\n 23  imat                      50545 non-null  object\n 24  fex_ilyl                  50545 non-null  object\n 25  ilyl                      50545 non-null  object\n 26  fex_icn                   50545 non-null  object\n 27  icn                       50545 non-null  object\n 28  fex_ifis                  50545 non-null  object\n 29  ifis                      50545 non-null  object\n 30  fex_iqui                  50545 non-null  object\n 31  iqui                      50545 non-null  object\n 32  fex_ibio                  50545 non-null  object\n 33  ibio                      50545 non-null  object\n 34  fex_ies                   50545 non-null  object\n 35  ies                       50545 non-null  object\n 36  fex_ihis                  50545 non-null  object\n 37  ihis                      50545 non-null  object\n 38  fex_ifil                  50545 non-null  object\n 39  ifil                      50545 non-null  object\n 40  fex_ied                   50545 non-null  object\n 41  ied                       50545 non-null  object\n 42  nl_imat                   50545 non-null  object\n 43  nl_ilyl                   50545 non-null  object\n 44  nl_icn                    50545 non-null  object\n 45  nl_ifis                   50545 non-null  object\n 46  nl_iqui                   50545 non-null  object\n 47  nl_ibio                   50545 non-null  object\n 48  nl_ies                    50545 non-null  object\n 49  nl_ihis                   50545 non-null  object\n 50  nl_ifil                   50545 non-null  object\n 51  nl_ied                    50545 non-null  object\n 52  ind_1                     50545 non-null  object\n 53  ind_2                     50545 non-null  object\n 54  ind_3                     50545 non-null  object\n 55  ind_4                     50545 non-null  object\n 56  ind_5                     50545 non-null  object\n 57  ind_6                     50545 non-null  object\n 58  ind_7                     50545 non-null  object\n 59  ind_8                     50545 non-null  object\n 60  ind_9                     50545 non-null  object\n 61  lc_1                      50545 non-null  object\n 62  lc_2                      50545 non-null  object\n 63  lc_3                      50545 non-null  object\n 64  lc_4                      50545 non-null  object\n 65  lc_5                      50545 non-null  object\n 66  lc_6                      50545 non-null  object\n 67  lc_7                      50545 non-null  object\n 68  lc_8                      50545 non-null  object\n 69  lc_9                      50545 non-null  object\n 70  lc_10                     50545 non-null  object\n 71  lc_11                     50545 non-null  object\n 72  lc_12                     50545 non-null  object\n 73  fex_rubrica               50545 non-null  object\n 74  estado_rub                50545 non-null  object\n 75  fex_lista_cotejo          50545 non-null  object\n 76  estado_lc                 50545 non-null  object\n 77  fex_honestidad_academica  50545 non-null  object\ndtypes: int64(11), object(67)\nmemory usage: 30.1+ MB"
  },
  {
    "objectID": "posts/introPandas/Intro_a_Pandas.html#selección-de-datos.",
    "href": "posts/introPandas/Intro_a_Pandas.html#selección-de-datos.",
    "title": "Introducción a Pandas",
    "section": "6 Selección de datos.",
    "text": "6 Selección de datos.\nPodemos seleccionar una o varias columnas específicas de un DataFrame utilizando las etiquetas. Se crea un nuevo DataFrame con las columnas especificadas.\n\n\n\nDe manera similar, podemos seleccionar filas utilizando el índice. Podemos seleccionar una o varias filas y se crea también un nuevo DataFrame\n\n\n\nPara seleccionar utilizando las etiquetas (nombres de filas y columnas) usamos el método loc(). Funciona como sigue:\ndf = data\n# Seleccionamos una sola columna.\nserie_columna = df.loc[:, ['Columna1']]\n\n# Seleccionamos más de una columna.\ndf_columnas = df.loc[:, ['Columna1','Columna2']]\n\n# Seleccionamos más de una fila.\ndf_filas = df.loc[['Indice1', 'Indice2'], :]\n\ndata.columns\n\nIndex(['ciclo', 'grado', 'estado_eval', 'codigo', 'amie', 'nm_regi',\n       'es_regeva', 'id_zona', 'id_dist', 'id_prov', 'id_cant', 'id_parr',\n       'financiamiento', 'sostenimiento', 'tp_sexo', 'na_eano', 'tp_area',\n       'etnibee', 'isec', 'quintil', 'fex_inev', 'inev', 'fex_imat', 'imat',\n       'fex_ilyl', 'ilyl', 'fex_icn', 'icn', 'fex_ifis', 'ifis', 'fex_iqui',\n       'iqui', 'fex_ibio', 'ibio', 'fex_ies', 'ies', 'fex_ihis', 'ihis',\n       'fex_ifil', 'ifil', 'fex_ied', 'ied', 'nl_imat', 'nl_ilyl', 'nl_icn',\n       'nl_ifis', 'nl_iqui', 'nl_ibio', 'nl_ies', 'nl_ihis', 'nl_ifil',\n       'nl_ied', 'ind_1', 'ind_2', 'ind_3', 'ind_4', 'ind_5', 'ind_6', 'ind_7',\n       'ind_8', 'ind_9', 'lc_1', 'lc_2', 'lc_3', 'lc_4', 'lc_5', 'lc_6',\n       'lc_7', 'lc_8', 'lc_9', 'lc_10', 'lc_11', 'lc_12', 'fex_rubrica',\n       'estado_rub', 'fex_lista_cotejo', 'estado_lc',\n       'fex_honestidad_academica'],\n      dtype='object')\n\n\n\n# Seleccionamos \ndata2 = data[[\"ciclo\",\"grado\"]].copy()\n\n\ndata2[\"grado\"].unique()\n\narray([10,  4,  7,  3], dtype=int64)\n\n\n\ndata2[data2[\"grado\"].isin([7,3])].head()\n\n\n\n\n\n\n\n\nciclo\ngrado\n\n\n\n\n69\n2023-2024\n7\n\n\n70\n2023-2024\n7\n\n\n71\n2023-2024\n7\n\n\n72\n2023-2024\n7\n\n\n73\n2023-2024\n7\n\n\n\n\n\n\n\n\n\n\nRequirement already satisfied: altair[all] in c:\\users\\meagu\\anaconda3\\lib\\site-packages (5.0.1)\nRequirement already satisfied: jinja2 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from altair[all]) (3.1.4)\nRequirement already satisfied: jsonschema&gt;=3.0 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from altair[all]) (4.23.0)\nRequirement already satisfied: numpy in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from altair[all]) (1.26.4)\nRequirement already satisfied: pandas&gt;=0.18 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from altair[all]) (2.2.3)\nRequirement already satisfied: toolz in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from altair[all]) (0.12.0)\nRequirement already satisfied: attrs&gt;=22.2.0 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from jsonschema&gt;=3.0-&gt;altair[all]) (23.1.0)\nRequirement already satisfied: jsonschema-specifications&gt;=2023.03.6 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from jsonschema&gt;=3.0-&gt;altair[all]) (2023.7.1)\nRequirement already satisfied: referencing&gt;=0.28.4 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from jsonschema&gt;=3.0-&gt;altair[all]) (0.30.2)\nRequirement already satisfied: rpds-py&gt;=0.7.1 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from jsonschema&gt;=3.0-&gt;altair[all]) (0.10.6)\nRequirement already satisfied: python-dateutil&gt;=2.8.2 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from pandas&gt;=0.18-&gt;altair[all]) (2.9.0.post0)\nRequirement already satisfied: pytz&gt;=2020.1 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from pandas&gt;=0.18-&gt;altair[all]) (2024.1)\nRequirement already satisfied: tzdata&gt;=2022.7 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from pandas&gt;=0.18-&gt;altair[all]) (2023.3)\nRequirement already satisfied: MarkupSafe&gt;=2.0 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from jinja2-&gt;altair[all]) (2.0.1)\nRequirement already satisfied: six&gt;=1.5 in c:\\users\\meagu\\anaconda3\\lib\\site-packages (from python-dateutil&gt;=2.8.2-&gt;pandas&gt;=0.18-&gt;altair[all]) (1.16.0)\nNote: you may need to restart the kernel to use updated packages.\n\n\nWARNING: altair 5.0.1 does not provide the extra 'all'\n\n\nTambién puedes seleccionar al mismo tiempo columnas y filas:\n\n\n\nEjercicio: - Del DataFrame de densidad poblacional, filtra las columnas de población y área, y las filas de Singapore, Bangladesh y Lebanon.\n\n#"
  },
  {
    "objectID": "posts/introPandas/Intro_a_Pandas.html#selección-de-datos-por-posición.",
    "href": "posts/introPandas/Intro_a_Pandas.html#selección-de-datos-por-posición.",
    "title": "Introducción a Pandas",
    "section": "7 Selección de datos por posición.",
    "text": "7 Selección de datos por posición.\nEn la sección anterior, seleccionamos dado a etiquetas, esto es, con los nombres de las filas y las columnas. Podemos hacer lo mismo pero está vez con la posición. Para esto, en lugar de loc() y at(), usamos iloc() y iat().\n# Seleccionamos las primeras 2 columnas.\ndf_columnas = df.iloc[:, 0:1]\n\n# Seleccionamos las últimas 3 filas\ndf_filas = df.iloc[-3:, :]\n\n# Elemento unico\ndato = df.iat[0, 0]\nRetomamos el ejemplo .\nEjercicio: - Del DataFrame del data, filtra y quédate solo con columnas y filas pares.\n\n# To Do"
  },
  {
    "objectID": "posts/Heatmap/HEATMAP.html",
    "href": "posts/Heatmap/HEATMAP.html",
    "title": "Heatmap",
    "section": "",
    "text": "Un heatmap es una representación gráfica de datos en la que los valores contenidos en una matriz se muestran mediante colores. Es como observar una tabla de datos “desde arriba”, donde cada celda refleja la magnitud de un valor en función de su tonalidad.\nEste tipo de gráfico es especialmente útil para obtener una visión general de un conjunto numérico, más que para extraer valores específicos.\nHeatmaps se utilizan con frecuencia para mostrar los resultados de un análisis de clustering jerárquico, acompañados de dendrogramas que agrupan filas y columnas según sus similitudes. Esto permite identificar patrones comunes, como países con características demográficas parecidas o variables fuertemente correlacionadas.\n\nVariaciones\n\nMostrar el resultado de un clustering y comparar con expectativas (ejemplo: agrupaciones por continente).\n\nIncluir los valores exactos en cada celda para facilitar la lectura numérica.\n\nUsarlos en series temporales donde existen patrones regulares.\n\nAplicarlos a matrices de adyacencia para redes o grafos.\n\n\n\nErrores habituales\n\nNo normalizar los datos antes de graficar.\n\nNo reordenar filas y columnas según los resultados de un clustering, lo que dificulta ver patrones.\n\nElegir una paleta de colores inadecuada, que confunda en lugar de resaltar diferencias.\n\n\n\nDataset: Precios Agroindustria de Cacao (2012 - 2025)\nArchivo: MAG_PreciosAgroindustriaCacao_2025Junio.csv\nFuente: Ministerio de Agricultura y Ganadería (MAG), Ecuador\nÚltima actualización: Junio 2025\n\nimport pandas as pd\ndf = pd.read_csv(\"mag_preciosagroindustriacacao_2025junio.csv\", sep=\";\")\nprint(df.head())\nprint(df.info())\n\n   PACC_ANIO PACC_MES DPA_PROVINCIA DPA_CANTON        PACC_PRODUCTO  \\\n0       2012    Enero        El Oro  Arenillas  Cacao seco mezclado   \n1       2012    Enero        El Oro  Arenillas  Cacao seco mezclado   \n2       2012    Enero        El Oro   El Guabo  Cacao seco mezclado   \n3       2012    Enero        El Oro   El Guabo  Cacao seco mezclado   \n4       2012    Enero        El Oro    Machala  Cacao seco mezclado   \n\n          PACC_PRESENTACION PACC_TIPO  PACC_PRECIO_USD  PACC_USD_KG  \n0  Quintal de 100,00 libras    Compra            71.41         1.57  \n1  Quintal de 100,00 libras     Venta            74.06         1.63  \n2  Quintal de 100,00 libras    Compra            73.75         1.63  \n3  Quintal de 100,00 libras     Venta            84.00         1.85  \n4  Quintal de 100,00 libras    Compra            75.00         1.65  \n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 26246 entries, 0 to 26245\nData columns (total 9 columns):\n #   Column             Non-Null Count  Dtype  \n---  ------             --------------  -----  \n 0   PACC_ANIO          26246 non-null  int64  \n 1   PACC_MES           26246 non-null  object \n 2   DPA_PROVINCIA      26246 non-null  object \n 3   DPA_CANTON         26246 non-null  object \n 4   PACC_PRODUCTO      26246 non-null  object \n 5   PACC_PRESENTACION  26246 non-null  object \n 6   PACC_TIPO          26246 non-null  object \n 7   PACC_PRECIO_USD    26246 non-null  float64\n 8   PACC_USD_KG        26246 non-null  float64\ndtypes: float64(2), int64(1), object(6)\nmemory usage: 1.8+ MB\nNone\n\n\n\n\nIteración 1\n\nimport plotly.express as px\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\n# Agrupar: precio promedio por año y cantón\ndf_pivot = (\n    df.groupby([\"PACC_ANIO\", \"DPA_CANTON\"])[\"PACC_PRECIO_USD\"]\n      .mean()\n      .reset_index()\n      .pivot(index=\"DPA_CANTON\", columns=\"PACC_ANIO\", values=\"PACC_PRECIO_USD\")\n)\n\n# Convertir el pivot a formato largo (para Plotly)\ndf_long = df_pivot.reset_index().melt(id_vars=\"DPA_CANTON\", var_name=\"PACC_ANIO\", value_name=\"PACC_PRECIO_USD\")\n\n# Crear heatmap\nfig = px.imshow(\n    df_pivot.values,\n    labels=dict(x=\"Año\", y=\"Cantón\", color=\"Precio USD\"),\n    x=df_pivot.columns,\n    y=df_pivot.index,\n    color_continuous_scale=\"Viridis\"\n)\n\n# Ajustes de diseño\nfig.update_layout(\n    title=\"Precio promedio en USD por año y cantón\",\n    xaxis=dict(side=\"top\"),  # años arriba\n    font=dict(family=\"Arial\", size=12),\n    plot_bgcolor=\"white\",\n    margin=dict(l=80, r=40, t=80, b=40)\n)\n\nfig.show()\n\n                                                \n\n\n\n\nIteración 2\n\nCambio de nulos por 0\nPresenta datos en cajas\n\n\n\n# Reemplazar NaN por 0\ndf_pivot = df_pivot.fillna(0)\n\n# Crear heatmap\nfig = px.imshow(\n    df_pivot.values,\n    labels=dict(x=\"Año\", y=\"Cantón\", color=\"Precio USD\"),\n    x=df_pivot.columns,\n    y=df_pivot.index,\n    color_continuous_scale=\"Viridis\",\n    text_auto=\".2f\"   # mostrar valores dentro de cada celda con 2 decimales\n)\n\n# Ajustes de diseño\nfig.update_layout(\n    title=\"Precio promedio en USD por año y cantón\",\n    xaxis=dict(side=\"top\"),\n    font=dict(family=\"Arial\", size=12),\n    plot_bgcolor=\"white\",\n    margin=dict(l=80, r=40, t=80, b=40)\n)\n\nfig.show()\n\n                                                \n\n\n\n\nIteración 3\n\nBorde cajas Blanco\nEliminación de eje y eje x\n\n\nimport pandas as pd\nimport plotly.express as px\n\n# Agrupar: precio promedio por año y cantón\ndf_pivot = (\n    df.groupby([\"PACC_ANIO\", \"DPA_CANTON\"])[\"PACC_PRECIO_USD\"]\n      .mean()\n      .reset_index()\n      .pivot(index=\"DPA_CANTON\", columns=\"PACC_ANIO\", values=\"PACC_PRECIO_USD\")\n)\n\n# Reemplazar NaN por 0\ndf_pivot = df_pivot.fillna(0)\n\n# Crear heatmap\nfig = px.imshow(\n    df_pivot.values,\n    labels=dict(x=\"Año\", y=\"Cantón\", color=\"Precio USD\"),\n    x=df_pivot.columns,\n    y=df_pivot.index,\n    color_continuous_scale=\"Viridis\"\n)\n\n# Borde blanco entre celdas\nfig.update_traces(\n    xgap=2,  # separación entre columnas\n    ygap=2   # separación entre filas\n)\n\n# Ajustes de diseño\nfig.update_layout(\n    title=\"Precio promedio en USD por año y cantón\",\n    xaxis=dict(side=\"top\", title=\"\"),   # Quitar nombre eje X\n    yaxis=dict(title=\"\"),               # Quitar nombre eje Y\n    font=dict(family=\"Arial\", size=12),\n    plot_bgcolor=\"white\",\n    margin=dict(l=80, r=40, t=80, b=40),\n    coloraxis_showscale=False           # Quitar barra de color\n)\n\nfig.show()\n\n                                                \n\n\n\n\nIteración 3\n\nOrdenamiento\n\n\n\n# Ordenar cantones por promedio total (de mayor a menor)\ndf_pivot = df_pivot.loc[df_pivot.mean(axis=1).sort_values(ascending=False).index]\n\n# Crear heatmap\nfig = px.imshow(\n    df_pivot.values,\n    labels=dict(x=\"Año\", y=\"Cantón\", color=\"Precio USD\"),\n    x=df_pivot.columns,\n    y=df_pivot.index,\n    color_continuous_scale=\"Viridis\"\n)\n\n# Ajustes de diseño\nfig.update_layout(\n    title=\"Precio promedio en USD por año y cantón\",\n\n    xaxis=dict(side=\"top\", title=\"\"),\n    yaxis=dict(title=\"\"),\n    font=dict(family=\"Arial\", size=12),\n    plot_bgcolor=\"white\",\n    margin=dict(l=80, r=40, t=80, b=40),\n    coloraxis_showscale=False\n)\n\nfig.show()"
  },
  {
    "objectID": "posts/foliumTimeline/folium_timeline.html",
    "href": "posts/foliumTimeline/folium_timeline.html",
    "title": "Mapa de Color tiempo",
    "section": "",
    "text": "Objetivo: Desarrollar una infografia georeferenciada de las votaciones del Ecuador del año del 2002. \n\n\nimport folium\nimport pandas as pd\nimport geopandas as gpd\nimport branca\nimport json\nfrom folium.plugins import TimestampedGeoJson\n\n\n\n\ndf_ecu = gpd.read_file(\"ecuador_provincias.json\")\ndf_ecu[\"name\"] = df_ecu[\"name\"].str.upper()\ndf_ecu.head()\n\n\n\n\n\n\n\n\nsource\nid\nname\ngeometry\n\n\n\n\n0\nhttps://simplemaps.com\nECE\nESMERALDAS\nMULTIPOLYGON (((-78.47812 1.18712, -78.47831 1...\n\n\n1\nhttps://simplemaps.com\nECC\nCARCHI\nPOLYGON ((-78.44211 0.87194, -78.44714 0.87437...\n\n\n2\nhttps://simplemaps.com\nECU\nSUCUMBIOS\nPOLYGON ((-77.81408 0.34566, -77.79186 0.37099...\n\n\n3\nhttps://simplemaps.com\nECD\nORELLANA\nPOLYGON ((-77.29941 -0.05855, -77.28401 -0.047...\n\n\n4\nhttps://simplemaps.com\nECY\nPASTAZA\nPOLYGON ((-77.05165 -1.01038, -77.07198 -1.033...\n\n\n\n\n\n\n\n\n\n\nMendoza, K., Medina, P., & Astudillo, P. (2025).\nEcuadorian Presidential Elections (2002–2023): Canton-Level Results for First and Second Rounds.\nHarvard Dataverse. https://doi.org/10.7910/DVN/A6ZP75\n\ndf = pd.read_csv(\"presidentes_votacion_cantonal_formato_angosto.csv\")\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 77462 entries, 0 to 77461\nData columns (total 9 columns):\n #   Column            Non-Null Count  Dtype \n---  ------            --------------  ----- \n 0   ANIO              77462 non-null  int64 \n 1   VUELTA            77462 non-null  int64 \n 2   PROVINCIA_CODIGO  77462 non-null  object\n 3   PROVINCIA_NOMBRE  77462 non-null  object\n 4   CANTON_CODIGO     77462 non-null  object\n 5   CANTON_NOMBRE     77462 non-null  object\n 6   CANDIDATO_NOMBRE  77462 non-null  object\n 7   AGRUPACION        77462 non-null  object\n 8   VOTOS             77462 non-null  int64 \ndtypes: int64(3), object(6)\nmemory usage: 5.3+ MB\n\n\n\n# agrupacion para obtener valos por provincia\ndf_gr = df.groupby([\"ANIO\", \"VUELTA\", \"PROVINCIA_NOMBRE\",\n        \"CANDIDATO_NOMBRE\",\"PROVINCIA_CODIGO\"])[\"VOTOS\"].sum().reset_index()\n# solo datos de Ecuador continental \ndf_gr = df_gr[~df_gr[\"PROVINCIA_NOMBRE\"].isin(['EUROPA, ASIA, '\n'OCEANIA', 'NORTE-AMERICA', 'LATAM, CARIBE, AFRICA'])]\n# agrupacion por voto mayoritario en provinica\ndf_max = df_gr.loc[\n    df_gr.groupby(['PROVINCIA_NOMBRE','ANIO','VUELTA'])['VOTOS'].idxmax()\n]\n\n\n\n\n\n# Load Ecuador's GeoJSON data\nwith open(\"ecuador_provincias.json\", \"r\", encoding=\"utf-8\") as f:\n    geo_json_data = json.load(f)\ndf_max.PROVINCIA_NOMBRE.unique()\n\narray(['AZUAY', 'BOLIVAR', 'CANAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI', 'EL ORO',\n       'ESMERALDAS', 'GALAPAGOS', 'GUAYAS', 'IMBABURA', 'LOJA', 'LOS RIOS', 'MANABI',\n       'MORONA SANTIAGO', 'NAPO', 'ORELLANA', 'PASTAZA', 'PICHINCHA', 'SANTA ELENA',\n       'STO DGO TSACHILAS', 'SUCUMBIOS', 'TUNGURAHUA', 'ZAMORA CHINCHIPE'], dtype=object)\n\n\n\n# Nombre de la provincias \nnombresGjson = sorted([x['properties'][\"name\"].upper() for x in geo_json_data['features']])\n# nombres a cambiar CAÑAR ,'SANTO DOMINGO DE LOS TSÁCHILAS' cambio en el dataset\ndf_max[\"PROVINCIA_NOMBRE\"] = df_max[\"PROVINCIA_NOMBRE\"].replace({'CANAR':'CAÑAR',\n                        'STO DGO TSACHILAS':'SANTO DOMINGO DE LOS TSÁCHILAS'})\ndf_max[\"PROVINCIA_NOMBRE\"].unique()\n\narray(['AZUAY', 'BOLIVAR', 'CAÑAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI', 'EL ORO',\n       'ESMERALDAS', 'GALAPAGOS', 'GUAYAS', 'IMBABURA', 'LOJA', 'LOS RIOS', 'MANABI',\n       'MORONA SANTIAGO', 'NAPO', 'ORELLANA', 'PASTAZA', 'PICHINCHA', 'SANTA ELENA',\n       'SANTO DOMINGO DE LOS TSÁCHILAS', 'SUCUMBIOS', 'TUNGURAHUA', 'ZAMORA CHINCHIPE'],\n      dtype=object)\n\n\n\n\n\n\n# COLORES POR CANDIDATO\nmapa_colores ={'ALVARO NOBOA':\"#980BEF\", 'JACOBO BUCARAM':\"#1070B9\", 'LUCIO GUTIERREZ':\"#E01212\",\n       'RODRIGO BORJA':\"#FEB00A\", 'XAVIER NEIRA':\"#F6FE69\",'RAFAEL CORREA':\"#07F93F\",\n       'LENIN MORENO':\"#07F93F\",'YAKU PEREZ':\"#F9D107\",'GUILLERMO LASSO':\"#1070B9\",\n         'LUISA GONZALEZ':\"#34FFF8\",'DANIEL NOBOA':\"#980BEF\", 'NULOS':\"#FFFFFF\",\n       'FERNANDO VILLAVICENCIO':\"#96B0FF\",'XAVIER HERVAS':\"#F9D107\", \n       'ANDRES ARAUZ':\"#07F93F\"\n       }\n# aplicar color al dataset\ndf_max['COLOR'] = df_max['CANDIDATO_NOMBRE'].apply(lambda x:mapa_colores.get(x))\ndf_max.head()\n\n\n\n\n\n\n\n\nANIO\nVUELTA\nPROVINCIA_NOMBRE\nCANDIDATO_NOMBRE\nPROVINCIA_CODIGO\nVOTOS\nCOLOR\n\n\n\n\n10\n2002\n1\nAZUAY\nRODRIGO BORJA\nEC01\n157246\n#FEB00A\n\n\n290\n2002\n2\nAZUAY\nLUCIO GUTIERREZ\nEC01\n371564\n#E01212\n\n\n397\n2006\n1\nAZUAY\nRAFAEL CORREA\nEC01\n166524\n#07F93F\n\n\n765\n2006\n2\nAZUAY\nRAFAEL CORREA\nEC01\n429830\n#07F93F\n\n\n879\n2009\n1\nAZUAY\nRAFAEL CORREA\nEC01\n418082\n#07F93F\n\n\n\n\n\n\n\n\ndef generar_start_end(row, col_anio='ANIO', col_vuelta='VUELTA'):\n    \"\"\"\n    Devuelve start y end como timestamps (ms) según:\n    - Vuelta 1: del 1 de enero al 1 de julio\n    - Vuelta 2: del 2 de julio al 31 diciembre\n    \"\"\"\n    anio = int(row[col_anio])\n    vuelta = int(row[col_vuelta])\n\n    if vuelta == 1:\n        start = pd.Timestamp(f\"{anio}-01-01 00:00:00\")\n        end   = pd.Timestamp(f\"{anio}-07-01 00:00:00\")\n    else:  # vuelta 2\n        start = pd.Timestamp(f\"{anio}-07-02 00:00:00\")\n        end   = pd.Timestamp(f\"{anio}-12-31 23:59:59\")\n\n    # convertir a timestamp en milisegundos\n    return {\n        'start': float(start.value // 10**6),\n        'end':   float(end.value   // 10**6)\n    }\n\n\ndf_max['start_end'] = df_max.apply(lambda x :\ngenerar_start_end(x, col_anio='ANIO', col_vuelta='VUELTA'),\n    axis=1\n)\n\n\ndf_merged = df_max.merge(df_ecu[['name', 'geometry']], \n                         left_on='PROVINCIA_NOMBRE', \n                         right_on='name', \n                         how='inner')\n# Convertir en GeoDataFrame\ngdf_final = gpd.GeoDataFrame(df_merged, geometry='geometry')\n\n\n\n\n\n\nfeatures = []\n\nfor _, row in gdf_final.iterrows():\n\n    start_ts = int(row['start_end']['start']) // 1000  # segundos UNIX\n\n    start_date = pd.to_datetime(start_ts, unit='s').strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    feature = {\n        \"type\": \"Feature\",\n        \"geometry\": row[\"geometry\"].__geo_interface__,\n        \"properties\": {\n            \"time\": start_date,\n            \"style\": {\n                \"color\": \"black\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                \"fillColor\": row[\"COLOR\"],\n                \"fillOpacity\": 0.8\n            },\n            \"tooltip\": f\"Provincia: {row['PROVINCIA_NOMBRE']} - {row['CANDIDATO_NOMBRE']}\",\n            \"popup\": (\n                f\"&lt;b&gt;Provincia:&lt;/b&gt; {row['PROVINCIA_NOMBRE']}&lt;br&gt;\"\n                f\"&lt;b&gt;Candidato:&lt;/b&gt; {row['CANDIDATO_NOMBRE']}&lt;br&gt;\"\n                f\"&lt;b&gt;Votos:&lt;/b&gt; {row['VOTOS']}&lt;br&gt;\"\n                f\"&lt;b&gt;Año:&lt;/b&gt; {row['ANIO']} - Vuelta {row['VUELTA']}\"\n            )\n        }\n    }\n    features.append(feature)\n\n\n\n\nm = folium.Map(\n    location=[-0.19899731681836336, -78.4428000494774],\n    tiles=\"Cartodb dark_matter\", ## estilo del fondo mapa\n    zoom_start=6\n)\n\n\n\n\n\nts = TimestampedGeoJson(\n    {\n        \"type\": \"FeatureCollection\",\n        \"features\": features,\n    },\n    period=\"P1Y\",\n    duration=\"P1Y\",\n    add_last_point=True,\n    auto_play=False,\n    loop=False\n).add_to(m)\n\n\n\n\n\n\nitems_html = \"\"\nfor candidato, color in mapa_colores.items():\n    items_html += f'''\n    &nbsp; &lt;i class=\"fa fa-square\" style=\"color:{color};\"&gt;&lt;/i&gt;\n    &nbsp; {candidato}&lt;br&gt;'''\n\nlegend_html = f\"\"\"\n{{% macro html(this, kwargs) %}}\n&lt;div style=\"\n     position: fixed;\n     bottom: 50px; left: 50px;\n     width: 250px;\n     border:2px solid grey;\n     z-index:9999;\n     font-size:14px;\n     background-color:white;\n     opacity: 0.9;\n     padding: 10px;\n     border-radius: 5px;\"&gt;\n     &lt;b&gt;🗳️ Candidato ganador&lt;/b&gt;&lt;br&gt;\n     {items_html}\n&lt;/div&gt;\n{{% endmacro %}}\n\"\"\"\n\nlegend = branca.element.MacroElement()\nlegend._template = branca.element.Template(legend_html)\nm.get_root().add_child(legend)\n\nm.save(\"VotEcuador_Timeline_Legend.html\")\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/foliumTimeline/folium_timeline.html#manejo-del-json-con-geopandas",
    "href": "posts/foliumTimeline/folium_timeline.html#manejo-del-json-con-geopandas",
    "title": "Mapa de Color tiempo",
    "section": "",
    "text": "df_ecu = gpd.read_file(\"ecuador_provincias.json\")\ndf_ecu[\"name\"] = df_ecu[\"name\"].str.upper()\ndf_ecu.head()\n\n\n\n\n\n\n\n\nsource\nid\nname\ngeometry\n\n\n\n\n0\nhttps://simplemaps.com\nECE\nESMERALDAS\nMULTIPOLYGON (((-78.47812 1.18712, -78.47831 1...\n\n\n1\nhttps://simplemaps.com\nECC\nCARCHI\nPOLYGON ((-78.44211 0.87194, -78.44714 0.87437...\n\n\n2\nhttps://simplemaps.com\nECU\nSUCUMBIOS\nPOLYGON ((-77.81408 0.34566, -77.79186 0.37099...\n\n\n3\nhttps://simplemaps.com\nECD\nORELLANA\nPOLYGON ((-77.29941 -0.05855, -77.28401 -0.047...\n\n\n4\nhttps://simplemaps.com\nECY\nPASTAZA\nPOLYGON ((-77.05165 -1.01038, -77.07198 -1.033..."
  },
  {
    "objectID": "posts/foliumTimeline/folium_timeline.html#etl-del-dataset",
    "href": "posts/foliumTimeline/folium_timeline.html#etl-del-dataset",
    "title": "Mapa de Color tiempo",
    "section": "",
    "text": "Mendoza, K., Medina, P., & Astudillo, P. (2025).\nEcuadorian Presidential Elections (2002–2023): Canton-Level Results for First and Second Rounds.\nHarvard Dataverse. https://doi.org/10.7910/DVN/A6ZP75\n\ndf = pd.read_csv(\"presidentes_votacion_cantonal_formato_angosto.csv\")\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 77462 entries, 0 to 77461\nData columns (total 9 columns):\n #   Column            Non-Null Count  Dtype \n---  ------            --------------  ----- \n 0   ANIO              77462 non-null  int64 \n 1   VUELTA            77462 non-null  int64 \n 2   PROVINCIA_CODIGO  77462 non-null  object\n 3   PROVINCIA_NOMBRE  77462 non-null  object\n 4   CANTON_CODIGO     77462 non-null  object\n 5   CANTON_NOMBRE     77462 non-null  object\n 6   CANDIDATO_NOMBRE  77462 non-null  object\n 7   AGRUPACION        77462 non-null  object\n 8   VOTOS             77462 non-null  int64 \ndtypes: int64(3), object(6)\nmemory usage: 5.3+ MB\n\n\n\n# agrupacion para obtener valos por provincia\ndf_gr = df.groupby([\"ANIO\", \"VUELTA\", \"PROVINCIA_NOMBRE\",\n        \"CANDIDATO_NOMBRE\",\"PROVINCIA_CODIGO\"])[\"VOTOS\"].sum().reset_index()\n# solo datos de Ecuador continental \ndf_gr = df_gr[~df_gr[\"PROVINCIA_NOMBRE\"].isin(['EUROPA, ASIA, '\n'OCEANIA', 'NORTE-AMERICA', 'LATAM, CARIBE, AFRICA'])]\n# agrupacion por voto mayoritario en provinica\ndf_max = df_gr.loc[\n    df_gr.groupby(['PROVINCIA_NOMBRE','ANIO','VUELTA'])['VOTOS'].idxmax()\n]"
  },
  {
    "objectID": "posts/foliumTimeline/folium_timeline.html#manejo-del-archivo-.json",
    "href": "posts/foliumTimeline/folium_timeline.html#manejo-del-archivo-.json",
    "title": "Mapa de Color tiempo",
    "section": "",
    "text": "# Load Ecuador's GeoJSON data\nwith open(\"ecuador_provincias.json\", \"r\", encoding=\"utf-8\") as f:\n    geo_json_data = json.load(f)\ndf_max.PROVINCIA_NOMBRE.unique()\n\narray(['AZUAY', 'BOLIVAR', 'CANAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI', 'EL ORO',\n       'ESMERALDAS', 'GALAPAGOS', 'GUAYAS', 'IMBABURA', 'LOJA', 'LOS RIOS', 'MANABI',\n       'MORONA SANTIAGO', 'NAPO', 'ORELLANA', 'PASTAZA', 'PICHINCHA', 'SANTA ELENA',\n       'STO DGO TSACHILAS', 'SUCUMBIOS', 'TUNGURAHUA', 'ZAMORA CHINCHIPE'], dtype=object)\n\n\n\n# Nombre de la provincias \nnombresGjson = sorted([x['properties'][\"name\"].upper() for x in geo_json_data['features']])\n# nombres a cambiar CAÑAR ,'SANTO DOMINGO DE LOS TSÁCHILAS' cambio en el dataset\ndf_max[\"PROVINCIA_NOMBRE\"] = df_max[\"PROVINCIA_NOMBRE\"].replace({'CANAR':'CAÑAR',\n                        'STO DGO TSACHILAS':'SANTO DOMINGO DE LOS TSÁCHILAS'})\ndf_max[\"PROVINCIA_NOMBRE\"].unique()\n\narray(['AZUAY', 'BOLIVAR', 'CAÑAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI', 'EL ORO',\n       'ESMERALDAS', 'GALAPAGOS', 'GUAYAS', 'IMBABURA', 'LOJA', 'LOS RIOS', 'MANABI',\n       'MORONA SANTIAGO', 'NAPO', 'ORELLANA', 'PASTAZA', 'PICHINCHA', 'SANTA ELENA',\n       'SANTO DOMINGO DE LOS TSÁCHILAS', 'SUCUMBIOS', 'TUNGURAHUA', 'ZAMORA CHINCHIPE'],\n      dtype=object)"
  },
  {
    "objectID": "posts/foliumTimeline/folium_timeline.html#estilo-del-mapa",
    "href": "posts/foliumTimeline/folium_timeline.html#estilo-del-mapa",
    "title": "Mapa de Color tiempo",
    "section": "",
    "text": "# COLORES POR CANDIDATO\nmapa_colores ={'ALVARO NOBOA':\"#980BEF\", 'JACOBO BUCARAM':\"#1070B9\", 'LUCIO GUTIERREZ':\"#E01212\",\n       'RODRIGO BORJA':\"#FEB00A\", 'XAVIER NEIRA':\"#F6FE69\",'RAFAEL CORREA':\"#07F93F\",\n       'LENIN MORENO':\"#07F93F\",'YAKU PEREZ':\"#F9D107\",'GUILLERMO LASSO':\"#1070B9\",\n         'LUISA GONZALEZ':\"#34FFF8\",'DANIEL NOBOA':\"#980BEF\", 'NULOS':\"#FFFFFF\",\n       'FERNANDO VILLAVICENCIO':\"#96B0FF\",'XAVIER HERVAS':\"#F9D107\", \n       'ANDRES ARAUZ':\"#07F93F\"\n       }\n# aplicar color al dataset\ndf_max['COLOR'] = df_max['CANDIDATO_NOMBRE'].apply(lambda x:mapa_colores.get(x))\ndf_max.head()\n\n\n\n\n\n\n\n\nANIO\nVUELTA\nPROVINCIA_NOMBRE\nCANDIDATO_NOMBRE\nPROVINCIA_CODIGO\nVOTOS\nCOLOR\n\n\n\n\n10\n2002\n1\nAZUAY\nRODRIGO BORJA\nEC01\n157246\n#FEB00A\n\n\n290\n2002\n2\nAZUAY\nLUCIO GUTIERREZ\nEC01\n371564\n#E01212\n\n\n397\n2006\n1\nAZUAY\nRAFAEL CORREA\nEC01\n166524\n#07F93F\n\n\n765\n2006\n2\nAZUAY\nRAFAEL CORREA\nEC01\n429830\n#07F93F\n\n\n879\n2009\n1\nAZUAY\nRAFAEL CORREA\nEC01\n418082\n#07F93F\n\n\n\n\n\n\n\n\ndef generar_start_end(row, col_anio='ANIO', col_vuelta='VUELTA'):\n    \"\"\"\n    Devuelve start y end como timestamps (ms) según:\n    - Vuelta 1: del 1 de enero al 1 de julio\n    - Vuelta 2: del 2 de julio al 31 diciembre\n    \"\"\"\n    anio = int(row[col_anio])\n    vuelta = int(row[col_vuelta])\n\n    if vuelta == 1:\n        start = pd.Timestamp(f\"{anio}-01-01 00:00:00\")\n        end   = pd.Timestamp(f\"{anio}-07-01 00:00:00\")\n    else:  # vuelta 2\n        start = pd.Timestamp(f\"{anio}-07-02 00:00:00\")\n        end   = pd.Timestamp(f\"{anio}-12-31 23:59:59\")\n\n    # convertir a timestamp en milisegundos\n    return {\n        'start': float(start.value // 10**6),\n        'end':   float(end.value   // 10**6)\n    }\n\n\ndf_max['start_end'] = df_max.apply(lambda x :\ngenerar_start_end(x, col_anio='ANIO', col_vuelta='VUELTA'),\n    axis=1\n)\n\n\ndf_merged = df_max.merge(df_ecu[['name', 'geometry']], \n                         left_on='PROVINCIA_NOMBRE', \n                         right_on='name', \n                         how='inner')\n# Convertir en GeoDataFrame\ngdf_final = gpd.GeoDataFrame(df_merged, geometry='geometry')"
  },
  {
    "objectID": "posts/foliumTimeline/folium_timeline.html#generación-de-features-para-el-timeline",
    "href": "posts/foliumTimeline/folium_timeline.html#generación-de-features-para-el-timeline",
    "title": "Mapa de Color tiempo",
    "section": "",
    "text": "features = []\n\nfor _, row in gdf_final.iterrows():\n\n    start_ts = int(row['start_end']['start']) // 1000  # segundos UNIX\n\n    start_date = pd.to_datetime(start_ts, unit='s').strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    feature = {\n        \"type\": \"Feature\",\n        \"geometry\": row[\"geometry\"].__geo_interface__,\n        \"properties\": {\n            \"time\": start_date,\n            \"style\": {\n                \"color\": \"black\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                \"fillColor\": row[\"COLOR\"],\n                \"fillOpacity\": 0.8\n            },\n            \"tooltip\": f\"Provincia: {row['PROVINCIA_NOMBRE']} - {row['CANDIDATO_NOMBRE']}\",\n            \"popup\": (\n                f\"&lt;b&gt;Provincia:&lt;/b&gt; {row['PROVINCIA_NOMBRE']}&lt;br&gt;\"\n                f\"&lt;b&gt;Candidato:&lt;/b&gt; {row['CANDIDATO_NOMBRE']}&lt;br&gt;\"\n                f\"&lt;b&gt;Votos:&lt;/b&gt; {row['VOTOS']}&lt;br&gt;\"\n                f\"&lt;b&gt;Año:&lt;/b&gt; {row['ANIO']} - Vuelta {row['VUELTA']}\"\n            )\n        }\n    }\n    features.append(feature)\n\n\n\n\nm = folium.Map(\n    location=[-0.19899731681836336, -78.4428000494774],\n    tiles=\"Cartodb dark_matter\", ## estilo del fondo mapa\n    zoom_start=6\n)\n\n\n\n\n\nts = TimestampedGeoJson(\n    {\n        \"type\": \"FeatureCollection\",\n        \"features\": features,\n    },\n    period=\"P1Y\",\n    duration=\"P1Y\",\n    add_last_point=True,\n    auto_play=False,\n    loop=False\n).add_to(m)"
  },
  {
    "objectID": "posts/foliumTimeline/folium_timeline.html#leyenda-candidato-y-color-y-visualizacion-final",
    "href": "posts/foliumTimeline/folium_timeline.html#leyenda-candidato-y-color-y-visualizacion-final",
    "title": "Mapa de Color tiempo",
    "section": "",
    "text": "items_html = \"\"\nfor candidato, color in mapa_colores.items():\n    items_html += f'''\n    &nbsp; &lt;i class=\"fa fa-square\" style=\"color:{color};\"&gt;&lt;/i&gt;\n    &nbsp; {candidato}&lt;br&gt;'''\n\nlegend_html = f\"\"\"\n{{% macro html(this, kwargs) %}}\n&lt;div style=\"\n     position: fixed;\n     bottom: 50px; left: 50px;\n     width: 250px;\n     border:2px solid grey;\n     z-index:9999;\n     font-size:14px;\n     background-color:white;\n     opacity: 0.9;\n     padding: 10px;\n     border-radius: 5px;\"&gt;\n     &lt;b&gt;🗳️ Candidato ganador&lt;/b&gt;&lt;br&gt;\n     {items_html}\n&lt;/div&gt;\n{{% endmacro %}}\n\"\"\"\n\nlegend = branca.element.MacroElement()\nlegend._template = branca.element.Template(legend_html)\nm.get_root().add_child(legend)\n\nm.save(\"VotEcuador_Timeline_Legend.html\")\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/Embudo/embudo.html",
    "href": "posts/Embudo/embudo.html",
    "title": "Gráfico de Embudo",
    "section": "",
    "text": "Los gráficos de embudo son una herramienta común para representar datos en las diferentes etapas de un proceso empresarial o en análisis de datos el resultado de un proceso de limpeza de datos o selección de caracterisiticas. Su función principal es mostrar cómo un conjunto inicial de elementos disminuye progresivamente a medida que avanza por las distintas fases de un flujo.\nEn el ámbito de la inteligencia de negocios, se utilizan con frecuencia para identificar posibles áreas problemáticas de un proceso. Por ejemplo, en el análisis de ventas permiten observar los ingresos o pérdidas en cada etapa y visualizar el porcentaje de usuarios o clientes que avanzan en el proceso. Utilizado tambien en las revisión sistematicas de literatura."
  },
  {
    "objectID": "posts/Embudo/embudo.html#cuándo-utilizar-un-gráfico-de-embudo",
    "href": "posts/Embudo/embudo.html#cuándo-utilizar-un-gráfico-de-embudo",
    "title": "Gráfico de Embudo",
    "section": "¿Cuándo utilizar un gráfico de embudo?",
    "text": "¿Cuándo utilizar un gráfico de embudo?\n\nProcesos de ventas o marketing digital, donde se analiza el abandono de usuarios en cada fase.\n\nFlujos de conversión (por ejemplo: visitas → registros → compras).\n\nProcesos de atención al cliente, donde interesa identificar los puntos donde los usuarios se detienen o se retiran.\n\nEs importante recordar que un embudo no explica las causas de los descensos, sino que ofrece una visión general que sirve de punto de partida para un análisis más profundo."
  },
  {
    "objectID": "posts/Embudo/embudo.html#estadísticas-relevantes-en-un-gráfico-de-embudo",
    "href": "posts/Embudo/embudo.html#estadísticas-relevantes-en-un-gráfico-de-embudo",
    "title": "Gráfico de Embudo",
    "section": "Estadísticas relevantes en un gráfico de embudo",
    "text": "Estadísticas relevantes en un gráfico de embudo\nEn cada etapa, se pueden resaltar diferentes métricas:\n\nRecuentos absolutos: el número total de usuarios que permanece en cada fase.\n\nProporciones relativas: el porcentaje de retención respecto al valor inicial.\n\nTasas de abandono entre etapas: muestran cuánto disminuye el conjunto en cada transición.\n\nSiempre que la visualización lo permita, es recomendable incluir tanto los valores absolutos como los relativos, cuidando de no sobrecargar el gráfico."
  },
  {
    "objectID": "posts/Embudo/embudo.html#problemas-comunes-y-mejores-prácticas",
    "href": "posts/Embudo/embudo.html#problemas-comunes-y-mejores-prácticas",
    "title": "Gráfico de Embudo",
    "section": "Problemas comunes y mejores prácticas",
    "text": "Problemas comunes y mejores prácticas\n\nRepresentación triangular distorsionada: en algunos casos se dibuja un triángulo donde cada etapa se ajusta al ancho correspondiente. Esto puede engañar visualmente sobre la magnitud de las pérdidas.\n\nEspaciado inconsistente entre fases: si los intervalos no son uniformes, se dificulta la comparación entre etapas.\n\nIncluir al menos tres etapas. Si solo existen dos, es preferible usar otros gráficos de parte–todo (gráfico barras o una barras apilada).\n\nMantener claridad visual en las proporciones representadas.\n\nUsar el embudo como visualización general y complementarlo con otras métricas o gráficos que expliquen el motivo de las caídas."
  },
  {
    "objectID": "posts/Embudo/embudo.html#realice-la-búsqueda-de-un-artículo-de-revisión-sistemática-slr-de-su-interés-y-elabore-un-gráfico-de-embudo-del-proceso-de-selección-de-articulos.",
    "href": "posts/Embudo/embudo.html#realice-la-búsqueda-de-un-artículo-de-revisión-sistemática-slr-de-su-interés-y-elabore-un-gráfico-de-embudo-del-proceso-de-selección-de-articulos.",
    "title": "Gráfico de Embudo",
    "section": "Realice la búsqueda de un artículo de revisión sistemática (SLR) de su interés y elabore un gráfico de embudo (del proceso de selección de articulos).",
    "text": "Realice la búsqueda de un artículo de revisión sistemática (SLR) de su interés y elabore un gráfico de embudo (del proceso de selección de articulos).\n\n\n\nalt text\n\n\n\nimport plotly.graph_objects as go\n\n# Etapas y valores del proceso\nstages = [\n    \"All sources Removal of duplicates\",\n    \"Exclusion/inclusion citeria\",\n    \"Candidate Papers\",\n    \"Selected primary papers\"\n]\n\nvalues = [1073, 996, 12, 12]\n\nfig = go.Figure(go.Funnel(\n    y=stages,\n    x=values,\n    text=[f\"{v}\" for v in values],\n    textposition=\"inside\",\n    textinfo=\"value+percent initial\",\n    opacity=0.5,\n    marker=dict(color=\"red\")\n))\n\nfig.update_layout(\n    title=\"Proceso de Selección de Artículos\",\n    margin=dict(l=80, r=40, t=60, b=40),\n    plot_bgcolor=\"white\",   # fondo del área del gráfico\n    paper_bgcolor=\"white\"   # fondo general\n)\n\nfig.show()"
  },
  {
    "objectID": "posts/CircleMap/rc.html",
    "href": "posts/CircleMap/rc.html",
    "title": "Mapas de burbujas folium",
    "section": "",
    "text": "Los mapas de burbujas (Bubble Maps) son una herramienta visual que permite representar información geográfica y cuantitativa al mismo tiempo.\nCada burbuja representa una ubicación específica, y su tamaño indica la magnitud del valor asociado.\nPueden representar:"
  },
  {
    "objectID": "posts/CircleMap/rc.html#errores-comunes-a-evitar",
    "href": "posts/CircleMap/rc.html#errores-comunes-a-evitar",
    "title": "Mapas de burbujas folium",
    "section": "Errores comunes a evitar",
    "text": "Errores comunes a evitar\n\nEscalas incorrectas\nSuperposición excesiva de burbujas\nColores sin significado\nDistorsión por proyección geográfica"
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html",
    "href": "posts/BFS_DFS/BFS.html",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "",
    "text": "Implement the BFS (Breadth-First Search) and DFS (Depth-First Search) algorithms in Python.\nVerify that BFS calculates the path with the fewest edges between two vertices of the graph.\nVerify that DFS allows finding all vertices accessible from a source vertex of the graph."
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#objectives",
    "href": "posts/BFS_DFS/BFS.html#objectives",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "",
    "text": "Implement the BFS (Breadth-First Search) and DFS (Depth-First Search) algorithms in Python.\nVerify that BFS calculates the path with the fewest edges between two vertices of the graph.\nVerify that DFS allows finding all vertices accessible from a source vertex of the graph."
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#introduction",
    "href": "posts/BFS_DFS/BFS.html#introduction",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "2. Introduction",
    "text": "2. Introduction\nBFS is a way to find all vertices accessible from a source vertex of a graph. The search resembles a wave that hits all vertices starting from node 1 (beginning). The FIFO queue Q is used to maintain the wavefront, and control is kept over nodes already included in the wave to prevent them from being revisited. BFS allows obtaining the shortest path from the source node to the other connected nodes. The efficiency of BFS is O(number of vertices + number of edges), commonly written as O(V + E) (V for the number of vertices, E for the number of edges). BFS is used to solve the following problems:\n\nTesting if a graph is connected.\nCalculating the spanning forest of the graph.\nCalculating for each vertex in the graph, a path with the minimum number of edges between the initial vertex and the current vertex or informing that no such path exists.\n\nDFS (Depth-First Search) is a systematic way of finding all vertices accessible from a source vertex. Like breadth-first search, DFS traverses a connected component of a given graph and defines a spanning tree. The basic idea of depth-first search is the following: it systematically explores each edge. We start over from different vertices as needed. As soon as we discover a vertex, DFS starts exploring from it (unlike BFS, which places a vertex in a queue to explore later), only backtracking when necessary (Muniswamy 2013). DFS is used to solve the following problems:\n\nTesting if the graph is connected.\nCalculating the spanning forest of the graph.\nCalculating a path between two vertices of the graph or informing that no such path exists.\nCalculating a cycle in the graph or informing that no such cycle exists."
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#exercise-1",
    "href": "posts/BFS_DFS/BFS.html#exercise-1",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "3. Exercise 1",
    "text": "3. Exercise 1\n\nA. Problem Statement\nImplement the BFS algorithm to answer the following questions: 1. Is there a path from CAB to BAT? 2. What is that path?\n\n\n\n\n\ngraph TD\n    CAB  --&gt; CAT \n    CAB  --&gt; CAR\n    CAR --&gt; CAT\n    CAR --&gt; BAR\n    CAT --&gt; MAT\n    CAT --&gt; BAT\n    MAT --&gt; BAT\n    BAR --&gt; MAT\n\n\n\n\n\n\n\n\n\nB. Implementation in Python\nTo implement the BFS algorithm in Python, a queue is used to enqueue the neighbor nodes of each source node. In the BFS function, two dictionaries are created: one called marked to mark nodes that have already been enqueued, and edgeto to assign each node its preceding node.\n\nfrom collections import deque\n\ndef busqueda_BFS(name,graph):\n    \"\"\"\n    busqueda_BFS Search Algorithm\n\n    Args:\n        start (str): The starting node.\n        graph (dict): The graph represented as an adjacency list.\n\n    Returns:\n        edgeto (dict): A dictionary containing the parent nodes of the connected component.\n    \"\"\"\n    ##############ESTRUCTURAS AUXILIARES \n    marked= dict.fromkeys(graph.keys(),False)\n    marked[name]=True\n    edgeto={name:\"inicio\"}\n    edgeto.update(dict.fromkeys(graph[name],name))\n    marked.update(dict.fromkeys(graph[name],True))\n    ##############ESTRUCTURAS AUXILIARES \n    search_queue = deque()\n    search_queue += graph[name] \n    searched = [] \n    while search_queue:\n        person = search_queue.popleft() \n        if not person in searched: \n            comprueba=[ nodo  for nodo in graph[person] if marked[nodo]==False ]\n            edgeto.update(dict.fromkeys(comprueba,person))\n            marked.update(dict.fromkeys(comprueba,True))\n            search_queue += graph[person] \n            searched.append(person)\n    return edgeto\n\ndef ruta(busqueda,edgeto):\n    \"\"\" Retorna ruta del componente conectado nodo inico\n        Args:\n            edgeto :(dict) diccionario que estan los nodos padres del componete conectado\n            busqueda :(str) nodo buscar\n        return:\n            ruta list() : lista que contiene la ruta\n    \"\"\"\n    ruta=[]\n    if (busqueda in edgeto.keys()):\n        while busqueda !=\"inicio\":\n            ruta.insert(0,busqueda)\n            busqueda=edgeto[busqueda]   \n    return ruta\n\n\n\nC. Execution of the Algorithm\n\nThe graph is constructed using a Python dictionary where the key is the node, and the value is a list of the node’s neighbors. Note that the graph to be analyzed (Illustration) is directed, so only the target neighbors should be included.\n\n\ngraph = {}\ngraph[\"CAB\"] = [\"CAT\", \"CAR\"]\ngraph[\"CAR\"] = [\"CAT\", \"BAR\"]\ngraph[\"CAT\"] = [\"MAT\",\"BAT\"]\ngraph[\"MAT\"] = [\"BAT\"]\ngraph[\"BAR\"] = [\"MAT\"]\ngraph[\"BAT\"] = []\n\n\nedgeto=busqueda_BFS(\"CAB\",graph)\nedgeto\n\n{'CAB': 'inicio',\n 'CAT': 'CAB',\n 'CAR': 'CAB',\n 'MAT': 'CAT',\n 'BAT': 'CAT',\n 'BAR': 'CAR'}\n\n\n\nruta(\"BAT\",edgeto)\n\n['CAB', 'CAT', 'BAT']\n\n\n\n\n\n\n\ngraph TD\n    CAB --&gt; CAT\n    CAT --&gt; BAT\n\n\n\n\n\n\n\n\nrutas={nodo:ruta(nodo,edgeto) for nodo in edgeto.keys()}\nrutas\n\n{'CAB': ['CAB'],\n 'CAT': ['CAB', 'CAT'],\n 'CAR': ['CAB', 'CAR'],\n 'MAT': ['CAB', 'CAT', 'MAT'],\n 'BAT': ['CAB', 'CAT', 'BAT'],\n 'BAR': ['CAB', 'CAR', 'BAR']}\n\n\n\n\n\n\n\ngraph TD\n    CAB --&gt; CAT\n    CAB --&gt; CAR\n    CAT --&gt; MAT\n    CAT --&gt; BAT\n    CAR --&gt; BAR"
  },
  {
    "objectID": "posts/BFS_DFS/BFS.html#exercise-2",
    "href": "posts/BFS_DFS/BFS.html#exercise-2",
    "title": "Algorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)",
    "section": "4. Exercise 2",
    "text": "4. Exercise 2\n\nD. Problem Statement\nWhat are the DFS Trees for the following graph G, given that the starting node is 0? Implement the DFS algorithm (using the recursive method) and use the necessary auxiliary structures.\n\n\n\n\n\ngraph TD\n    0 &lt;--&gt; 2\n    0 &lt;--&gt; 1\n    0 &lt;--&gt; 5\n    1 &lt;--&gt; 2\n    2 &lt;--&gt; 3\n    2 &lt;--&gt; 4\n    3 &lt;--&gt; 5\n    3 &lt;--&gt; 4\n    6 &lt;--&gt; 7\n\n\n\n\n\n\n\n\ndef dfs( graph, node,visited=set()):\n    \"\"\"algortimo dfs\n        Args:\n            graph :(dict) diccionario que representa grafo\n            node :(str) nodo fuente o raiz\n            visited:control nodos visitados default set()\n        return:\n            ruta list() : lista que contiene la ruta\n    \"\"\"\n    if node not in visited: ##comparacion si el nodo no se ha visitad\n        print (node)##impresion de nodos visitados\n        visited.add(node) ##agregando nodos visitados\n        marked[node]=True##control de nodos visitados\n        for neighbour in graph[node]:\n            comprueba=[ nodo  for nodo in graph[node] if marked[nodo]==False ]##comprovacion\n            edgeto.update(dict.fromkeys(comprueba,node))##llenado de edgeto\n            dfs(graph, neighbour,visited)\n\n\ndef ruta_DFS(busqueda,edgeto):\n    \"\"\" Retorna ruta del componente conectado nodo inico\n        Args:\n            edgeto :(dict) diccionario que estan los nodos padres del componete conectado\n            busqueda :(str) nodo buscar\n        return:\n            ruta list() : lista que contiene la ruta\n    \"\"\"\n    ruta=[]\n    while busqueda !=\"\":\n        ruta.insert(0,busqueda)\n        busqueda=edgeto[busqueda]\n    return ruta\n\n\n\nExecution of the Algorithm\n\nDefine the graph and the starting node 0 as input parameters.\n\n\n#graph\ngraph = dict()\ngraph[\"0\"] = [\"2\", \"1\",\"5\"]\ngraph[\"1\"] = [\"0\", \"2\"]\ngraph[\"2\"] = [\"0\",\"1\",\"3\",\"4\"]\ngraph[\"3\"] = [\"5\",\"4\",\"2\"]\ngraph[\"4\"] = [\"3\",\"2\"]\ngraph[\"5\"] = [\"3\",\"0\"]\nmarked= dict.fromkeys(graph.keys(),False)\nedgeto= dict.fromkeys(graph.keys(),\"\")\n\n\nThe execution of DFS provides the complete edgeto structure, which allows generating the route tree of the connected component, the DFS Tree.\n\n\ndfs(graph,\"0\")\n\n0\n2\n1\n3\n5\n4\n\n\n\nTo obtain all the routes, the route function was executed with the edgeto obtained for each node, storing this result in the routes dictionary, which allows knowing the route from the origin to each node.\n\n\nedgeto\n\n{'0': '', '1': '2', '2': '0', '3': '2', '4': '3', '5': '3'}\n\n\n\nrutas={nodo:ruta_DFS(nodo,edgeto) for nodo in edgeto.keys()}\nrutas\n\n{'0': ['0'],\n '1': ['0', '2', '1'],\n '2': ['0', '2'],\n '3': ['0', '2', '3'],\n '4': ['0', '2', '3', '4'],\n '5': ['0', '2', '3', '5']}\n\n\n\n\n\n\n\ngraph TD\n 0 --&gt; 2\n 2 --&gt; 1\n 2 --&gt; 3\n 3 --&gt; 4\n 3 --&gt; 5"
  },
  {
    "objectID": "notebooks.html",
    "href": "notebooks.html",
    "title": "Notebooks",
    "section": "",
    "text": "Worldwide Development\n\n\n\n\n\n\n\n\nGapminder Analytics\n\n\n\n\n\n\n\n\n\n\n\n\nMapas de burbujas folium\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 29, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nfolium points\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 27, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nHeatmap folium\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 27, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nMapa de Color\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nMapa de Color tiempo\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nTime Map\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nHeatmap\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nOct 1, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nHeatmap\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 29, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nLollipop\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 29, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nCircular Packing\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 24, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráficos de Pastel\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 24, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Embudo\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nMapa de árbol\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Densidad\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 17, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nViolin Plot\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 17, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nDiagrama de Caja y Bigotes\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 15, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nHistograma\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 15, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nTitulo del Poster\n\n\n\nPython\n\nHerramientas utilizadas\n\nPlotly\n\ntipo de grafico\n\n\n\n\n\n\n\n\n\nSep 11, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nIsotype\n\n\n\nPython\n\ncode\n\nVisualization\n\nIsotype\n\n\n\n\n\n\n\n\n\nSep 10, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nWord Cloud\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 10, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Datos Faltantes\n\n\n\nPython\n\ncode\n\nVisualization\n\nmissing data\n\n\n\n\n\n\n\n\n\nSep 8, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nDiagramas de puntos\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 8, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Lineas\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 3, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Barras\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 1, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducción a Pandas\n\n\n\nPython\n\ncode\n\npandas\n\n\n\n\n\n\n\n\n\nAug 27, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducción a Python I\n\n\n\nPython\n\ncode\n\n\n\n\n\n\n\n\n\nAug 25, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nValor de la Visualización de Datos\n\n\n\ndata_viz\n\n\n\n\n\n\n\n\n\nAug 20, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nEcuador Geo-Visualization: Heatmap by Region\n\n\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nJul 26, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)\n\n\n\nnews\n\ncode\n\nalgorithms\n\nPython\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nStrava GPX Plotter: Mapping Beautiful Journeys with Folium in Python\n\n\n\nnews\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nStrava Route Plot OSMNX\n\n\n\nnews\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nMar 17, 2022\n\n\nMarco Aguirre\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Marco Aguirre",
    "section": "",
    "text": "Worldwide Development\n\n\n\n\n\n\n\n\nGapminder Analytics\n\n\n\n\n\n\n\n\n\n\n\n\nMapas de burbujas folium\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 29, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nfolium points\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 27, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nHeatmap folium\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 27, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nMapa de Color\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nMapa de Color tiempo\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nTime Map\n\n\n\ndataviz\n\ncode\n\nfolium\n\n\n\n\n\n\n\n\n\nOct 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nHeatmap\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nOct 1, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nHeatmap\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 29, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nLollipop\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 29, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nCircular Packing\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 24, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráficos de Pastel\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 24, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Embudo\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nMapa de árbol\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 22, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Densidad\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 17, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nViolin Plot\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 17, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nDiagrama de Caja y Bigotes\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 15, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nHistograma\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 15, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nTitulo del Poster\n\n\n\nPython\n\nHerramientas utilizadas\n\nPlotly\n\ntipo de grafico\n\n\n\n\n\n\n\n\n\nSep 11, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nIsotype\n\n\n\nPython\n\ncode\n\nVisualization\n\nIsotype\n\n\n\n\n\n\n\n\n\nSep 10, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nWord Cloud\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 10, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Datos Faltantes\n\n\n\nPython\n\ncode\n\nVisualization\n\nmissing data\n\n\n\n\n\n\n\n\n\nSep 8, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nDiagramas de puntos\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 8, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Lineas\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 3, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nGráfico de Barras\n\n\n\nPython\n\ncode\n\nVisualization\n\n\n\n\n\n\n\n\n\nSep 1, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducción a Pandas\n\n\n\nPython\n\ncode\n\npandas\n\n\n\n\n\n\n\n\n\nAug 27, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nIntroducción a Python I\n\n\n\nPython\n\ncode\n\n\n\n\n\n\n\n\n\nAug 25, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nValor de la Visualización de Datos\n\n\n\ndata_viz\n\n\n\n\n\n\n\n\n\nAug 20, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nEcuador Geo-Visualization: Heatmap by Region\n\n\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nJul 26, 2025\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nAlgorithm Depth-First Search (DFS) AND Breadth-First Search (BFS)\n\n\n\nnews\n\ncode\n\nalgorithms\n\nPython\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nStrava GPX Plotter: Mapping Beautiful Journeys with Folium in Python\n\n\n\nnews\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nMarco Aguirre\n\n\n\n\n\n\n\n\n\n\n\n\nStrava Route Plot OSMNX\n\n\n\nnews\n\ncode\n\nvisualization\n\n\n\n\n\n\n\n\n\nMar 17, 2022\n\n\nMarco Aguirre\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Marco Aguirre",
    "section": "",
    "text": "Master of Computer Science with a focus on Intelligent Systems, seeking to provide support and solutions to optimize processes and make data-driven decisions. Passionate about problem-solving and innovation through data science."
  },
  {
    "objectID": "index.html#professional-summary",
    "href": "index.html#professional-summary",
    "title": "Marco Aguirre",
    "section": "",
    "text": "Master of Computer Science with a focus on Intelligent Systems, seeking to provide support and solutions to optimize processes and make data-driven decisions. Passionate about problem-solving and innovation through data science."
  },
  {
    "objectID": "index.html#professional-objective",
    "href": "index.html#professional-objective",
    "title": "Marco Aguirre",
    "section": "Professional Objective",
    "text": "Professional Objective\nTo apply my experience in Data Analysis, Machine Learning, Information Technology, and software development to solve complex problems and provide data-driven solutions that drive informed decision-making within an organization. Committed to the continuous pursuit of excellence in data science, exploring new techniques, and innovatively using technology to address business challenges."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Marco Aguirre",
    "section": "Education",
    "text": "Education\n\nMaster of Computer Science with a focus on Intelligent Systems | National Polytechnic School | Quito, Ecuador | 2021 - 2023|\nElectronics and Telecommunications Engineering |Armed Forces University - ESPE | Sangolqui, Ecuador | 2012 - 2018"
  },
  {
    "objectID": "index.html#professional-experience",
    "href": "index.html#professional-experience",
    "title": "Marco Aguirre",
    "section": "Professional Experience",
    "text": "Professional Experience\n\nResearch Technician | National Polytechnic School | 2021 - now | Management and analysis of research with data and its collection, cleaning, analysis, preprocessing, and modeling. Development of Data Mining projects.\nTechnical Support | FIXGROUP | 2019 - 2021 | Management of wireless links, design of hotspots, and managed Wi-Fi through Aruba.\nResearch Assistant | Armed Forces University ESPE | 2017 - 2018 | Management of wireless networks and exploration of new wireless communication technologies."
  },
  {
    "objectID": "index.html#publications",
    "href": "index.html#publications",
    "title": "Marco Aguirre",
    "section": "Publications",
    "text": "Publications\n\nGoSS-Rec: Group-Oriented Segment Sequence Recommendation\nAguirre, Marco; Recalde, Lorena; Loza-Aguirre, Edison\nInformation, Vol. 16, No. 8, Article 668, 2025.\nDOI: 10.3390/info16080668\nURL: https://www.mdpi.com/2078-2489/16/8/668\nA Graph-Based Analysis of Collaboration, Trends, and Ethical Dynamics: Perspectives on Ecuadorian Academic Research\nICEDEG 2025 - Eleventh International Conference on eDemocracy & eGovernment, 2025.\nDOI: 10.1109/ICEDEG65568.2025.11081533\nEvaluating embedded semantics for accessibility description of web crawl data\nAHFE International Conference, Vol. 94, 2023.\nDOI: 10.54941/ahfe1003774"
  },
  {
    "objectID": "posts/Barplot/graficoBarras.html",
    "href": "posts/Barplot/graficoBarras.html",
    "title": "Gráfico de Barras",
    "section": "",
    "text": "Un gráfico de barras representa valores de datos mediante barras verticales, lo que permite comparar distintos conjuntos en paralelo y, en ocasiones, visualizar tendencias. Este tipo de gráfico refleja la relación entre una variable categórica y una numérica: cada categoría se muestra como una barra cuyo tamaño corresponde a su valor. Aunque a menudo se considera una forma simple o incluso poco atractiva de visualización, en realidad es una de las más efectivas para este propósito.\nPara mejorar su claridad, conviene:\n- Ordenar las barras (especialmente de mayor a menor si la data no tiene un orden natural).\n- Añadir anotaciones adecuadas.\n- Iniciar siempre en cero para evitar distorsiones.\n- Verificar si los ejes son necesarios (en ocasiones pueden eliminarse para simplificar).\n- Elegir colores adecuados que faciliten la comparación y resalten la información clave."
  },
  {
    "objectID": "posts/Barplot/graficoBarras.html#ventajas-de-plotly",
    "href": "posts/Barplot/graficoBarras.html#ventajas-de-plotly",
    "title": "Gráfico de Barras",
    "section": "2.1 Ventajas de Plotly",
    "text": "2.1 Ventajas de Plotly\n\nInteractividad avanzada: zoom, hover, selección de datos, filtros dinámicos.\n\nAmplia variedad de gráficos: desde básicos (barras, líneas, dispersión) hasta complejos (mapas geoespaciales, gráficos 3D, series temporales).\n\nIntegración con Dash: permite crear aplicaciones web de análisis sin necesidad de conocimientos avanzados de front-end.\n\nCompatibilidad con múltiples lenguajes: Python, R, Julia y JavaScript.\n\nListo para producción: ideal para storytelling con datos, reportes ejecutivos y presentaciones interactivas."
  },
  {
    "objectID": "posts/Barplot/graficoBarras.html#página-oficial-y-documentación",
    "href": "posts/Barplot/graficoBarras.html#página-oficial-y-documentación",
    "title": "Gráfico de Barras",
    "section": "2.2 Página oficial y documentación",
    "text": "2.2 Página oficial y documentación\n\nSitio web: Plotly Python Open Source Graphing Library – incluye secciones como Getting Started, Gallery, API Reference y Dash.\n\n\n\nimport plotly.express as px\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\n\n\n# Agrupar para obtener el precio promedio por año\ndf_avg_anio = df.groupby(\"PACC_ANIO\", as_index=False)[\"PACC_PRECIO_USD\"].mean()\n\n# Gráfico de barras con colores personalizados\nfig = px.bar(\n    df_avg_anio,\n    x=\"PACC_ANIO\",\n    y=\"PACC_PRECIO_USD\",\n    text=\"PACC_PRECIO_USD\",\n    color=\"PACC_PRECIO_USD\",   # Colorear según valor\n    color_continuous_scale=\"Viridis\",  # Escala de color\n    title=\"Precio promedio en USD por año\",\n    orientation=\"v\",\n    labels={\"PACC_ANIO\": \"Año\", \"PACC_PRECIO_USD\": \"Precio USD\"}\n)\n\n# valores encima de las barras\nfig.update_traces(\n    texttemplate=\"%{text:.2f}\", \n    textposition=\"outside\",\n    marker=dict(line=dict(color=\"black\", width=1))  # borde negro a cada barra\n)\n\n# Ajustar diseño general\nfig.update_layout(\n    xaxis=dict(\n        type=\"category\", \n        showgrid=True, \n        showline=True, \n        linewidth=2, \n        linecolor=\"black\", \n        tickangle=0  # puedes poner -45 si hay muchos años\n    ),\n    yaxis=dict(\n        showgrid=True, \n        gridcolor=\"lightgray\", \n        zeroline=False, \n        title=\"Precio USD\"\n    ),\n    title=dict(\n        font=dict(size=22, family=\"Arial\", color=\"darkblue\"),\n        x=0.5,  # centrar título\n        xanchor=\"center\"\n    ),\n    plot_bgcolor=\"white\",   # fondo blanco\n    paper_bgcolor=\"white\",\n    font=dict(family=\"Arial\", size=14, color=\"black\"),\n    margin=dict(l=40, r=40, t=80, b=40)\n)\n\n# Mostrar gráfico\nfig.show()\n\n                                                \n\n\n\n\nimport plotly.express as px\n\n# Gráfico de barras con colores personalizados\nfig = px.bar(\n    df_avg_anio,\n    x=\"PACC_ANIO\",\n    y=\"PACC_PRECIO_USD\",\n    text=\"PACC_PRECIO_USD\",\n    title=\"Precio promedio en (USD por año)\",\n)\n\n# valores encima de las barras\nfig.update_traces(\n    texttemplate=\"%{text:.2f}\", \n    textposition=\"outside\",\n    marker=dict(line=dict(color=\"black\", width=1))  # borde negro a cada barra\n)\n\n# Ajustar diseño general\nfig.update_layout(\n    xaxis=dict(\n        type=\"category\", \n        showgrid=False, \n        showline=False, \n        linewidth=2, \n        linecolor=\"black\", \n        tickangle=0 ,\n        title=None \n    ),\n    yaxis=dict(\n        showgrid=False, \n        #gridcolor=\"lightgray\", \n        zeroline=False, \n       # title=\"Precio USD\",\n        showticklabels=False,   #  oculta valores del eje Y\n        title=None \n    ),\n    title=dict(\n        font=dict(size=22, family=\"Arial\", color=\"darkblue\"),\n        x=0.5,  # centrar título\n        xanchor=\"center\"\n    ),\n    plot_bgcolor=\"white\",   # fondo blanco\n    paper_bgcolor=\"white\",\n    font=dict(family=\"Arial\", size=14, color=\"black\"),\n    margin=dict(l=40, r=40, t=80, b=40)\n)\n\n# Mostrar gráfico\nfig.show()"
  },
  {
    "objectID": "posts/Barplot/graficoBarras.html#color",
    "href": "posts/Barplot/graficoBarras.html#color",
    "title": "Gráfico de Barras",
    "section": "3.1 Color",
    "text": "3.1 Color\n\nimport panel as pn\npn.extension()\n\n# Widget ColorPicker\ncolorpicker = pn.widgets.ColorPicker(name='Color Picker', value='#99ef78')\ncolorpicker\n\nC:\\Users\\meagu\\AppData\\Local\\Temp\\ipykernel_29140\\1456278253.py:2: UserWarning:\n\nUsing Panel interactively in VSCode notebooks requires the jupyter_bokeh package to be installed. You can install it with:\n\n   pip install jupyter_bokeh\n\nor:\n    conda install jupyter_bokeh\n\nand try again.\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n  \n\n\n\n\n\ncolorpicker.value\n\n'#99ef78'\n\n\n\ndf.columns\n\nIndex(['PACC_ANIO', 'PACC_MES', 'DPA_PROVINCIA', 'DPA_CANTON', 'PACC_PRODUCTO',\n       'PACC_PRESENTACION', 'PACC_TIPO', 'PACC_PRECIO_USD', 'PACC_USD_KG'],\n      dtype='object')\n\n\n\nimport pandas as pd\nimport plotly.express as px\n\n# 1) Filtrar 2025 (funciona si PACC_ANIO es int o str)\ndf_2025 = df[df[\"PACC_ANIO\"].astype(str) == \"2025\"].copy()\n\n# 2) Promedio por PRODUCTO (ya que agrupaste por producto)\ndf_avg_prod = (\n    df_2025.groupby(\"PACC_PRODUCTO\", as_index=False)\n           .agg(PACC_PRECIO_USD=(\"PACC_PRECIO_USD\", \"mean\"))\n           #.sort_values(\"PACC_PRECIO_USD\", ascending=False)\n)\n\n# 3) Gráfico\nfig = px.bar(\n    df_avg_prod,\n    x=\"PACC_PRODUCTO\",           # &lt;-- antes estaba \"PACC_ANIO\" (no existe tras agrupar)\n    y=\"PACC_PRECIO_USD\",\n    text=\"PACC_PRECIO_USD\",\n    title=\"Precio promedio (USD) por producto – 2025\",\n    \n)\n\nfig.update_traces(\n    texttemplate=\"%{text:.2f}\",\n    textposition=\"outside\",\n    marker=dict(line=dict(color=\"black\", width=1))\n)\n\nfig.update_layout(\n    xaxis=dict(type=\"category\", showgrid=False, showline=False, tickangle=0, title=None),\n    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False, title=None),\n    title=dict(font=dict(size=22, family=\"Arial\", color=\"darkblue\"), x=0.5, xanchor=\"center\"),\n    plot_bgcolor=\"white\", paper_bgcolor=\"white\",\n    font=dict(family=\"Arial\", size=14, color=\"black\"),\n    margin=dict(l=40, r=40, t=80, b=40)\n)\n\nfig.show()\n\n\n                                                \n\n\n\nimport pandas as pd\nimport plotly.express as px\n\n# 1) Filtrar 2025\ndf_2025 = df[df[\"PACC_ANIO\"].astype(str) == \"2025\"].copy()\n\n# 2) Promedio por PRODUCTO\ndf_avg_prod = (\n    df_2025.groupby(\"PACC_PRODUCTO\", as_index=False)\n           .agg(PROM_PRECIO_USD=(\"PACC_PRECIO_USD\", \"mean\"))\n)\n\n# (Opcional) ordenar para controlar el orden visual (arriba→abajo)\ndf_avg_prod = df_avg_prod.sort_values(\"PROM_PRECIO_USD\", ascending=True)\n\n# 3) Gráfico horizontal (x = métrica, y = categoría)\nfig = px.bar(\n    df_avg_prod,\n    x=\"PROM_PRECIO_USD\",\n    y=\"PACC_PRODUCTO\",\n    text=\"PROM_PRECIO_USD\",\n    title=\"Precio promedio (USD) por producto – 2025\",\n    orientation=\"h\",\n)\n\nfig.update_traces(\n    texttemplate=\"%{text:.2f}\",\n    textposition=\"outside\",\n    marker=dict(line=dict(color=\"black\", width=1))\n)\n\nfig.update_layout(\n    xaxis=dict(title=None, showgrid=False, zeroline=False),\n    yaxis=dict(\n        title=None, showgrid=False,\n        categoryorder=\"array\",                   # respeta tu orden\n        categoryarray=df_avg_prod[\"PACC_PRODUCTO\"].tolist()\n    ),\n    title=dict(font=dict(size=22, family=\"Arial\", color=\"darkblue\"), x=0.5, xanchor=\"center\"),\n    plot_bgcolor=\"white\", paper_bgcolor=\"white\",\n    font=dict(family=\"Arial\", size=14, color=\"black\"),\n    margin=dict(l=10, r=90, t=80, b=40),       # margen derecho para textos \"outside\"\n    height=40*len(df_avg_prod) + 200           # (opcional) altura dinámica\n)\n\n# Si quieres el mayor valor arriba:\n# fig.update_yaxes(autorange=\"reversed\")\n\nfig.show()"
  },
  {
    "objectID": "posts/Barplot/graficoBarras.html#cuál-debería-ser-la-gráfica-para-mostrar-el-precio-promedio-usd-por-año",
    "href": "posts/Barplot/graficoBarras.html#cuál-debería-ser-la-gráfica-para-mostrar-el-precio-promedio-usd-por-año",
    "title": "Gráfico de Barras",
    "section": "3.2 ¿Cuál debería ser la gráfica para mostrar el precio promedio (USD) por año?",
    "text": "3.2 ¿Cuál debería ser la gráfica para mostrar el precio promedio (USD) por año?"
  },
  {
    "objectID": "posts/Barplot/graficoBarras.html#realiza-un-gráfico-de-barras-con-un-nuevo-dataset",
    "href": "posts/Barplot/graficoBarras.html#realiza-un-gráfico-de-barras-con-un-nuevo-dataset",
    "title": "Gráfico de Barras",
    "section": "3.3 Realiza un gráfico de barras con un nuevo dataset",
    "text": "3.3 Realiza un gráfico de barras con un nuevo dataset"
  },
  {
    "objectID": "posts/Boxplot/boxplot.html",
    "href": "posts/Boxplot/boxplot.html",
    "title": "Diagrama de Caja y Bigotes",
    "section": "",
    "text": "El boxplot (o diagrama de caja y bigotes) es un método estandarizado para representar gráficamente una serie de datos numéricos a través de sus cuartiles. Este gráfico resume la distribución de los datos y permite identificar de manera rápida características esenciales de la variable estudiada."
  },
  {
    "objectID": "posts/Boxplot/boxplot.html#descripción",
    "href": "posts/Boxplot/boxplot.html#descripción",
    "title": "Diagrama de Caja y Bigotes",
    "section": "0.1 Descripción",
    "text": "0.1 Descripción\n\nLa línea central dentro de la caja representa la mediana.\n\nLos extremos de la caja corresponden al primer cuartil (Q1) y al tercer cuartil (Q3).\n\nLos llamados “bigotes” representan los valores máximo y mínimo, excluyendo los valores atípicos (outliers).\n\nLos valores atípicos, cuando existen, se representan como puntos individuales fuera de los bigotes.\n\n\n\n\nEjemplo de Boxplot"
  },
  {
    "objectID": "posts/Boxplot/boxplot.html#utilidad",
    "href": "posts/Boxplot/boxplot.html#utilidad",
    "title": "Diagrama de Caja y Bigotes",
    "section": "0.2 Utilidad",
    "text": "0.2 Utilidad\n\nProporcionan una visión general de la simetría de la distribución de los datos. Si la mediana no está centrada en la caja, la distribución es asimétrica.\n\nSon útiles para detectar la presencia de valores atípicos.\n\nForman parte de las herramientas de la estadística descriptiva, mostrando cómo se dispersan los datos con relación a la mediana, los percentiles 25 y 75, y los valores extremos.\n\nPermiten condensar en una sola dimensión la información de un histograma, facilitando el análisis al evidenciar que el 50 % de los datos se concentra dentro de los límites de la caja.\n\nAunque los resultados suelen expresarse en términos de cuartiles, en la práctica se utilizan las bisagras de Tukey para la construcción del gráfico. En muestras grandes, ambos métodos producen resultados muy similares."
  },
  {
    "objectID": "posts/Boxplot/boxplot.html#errores-comunes-al-interpretar-un-boxplot",
    "href": "posts/Boxplot/boxplot.html#errores-comunes-al-interpretar-un-boxplot",
    "title": "Diagrama de Caja y Bigotes",
    "section": "0.3 Errores comunes al interpretar un Boxplot",
    "text": "0.3 Errores comunes al interpretar un Boxplot\n\nEl gráfico no muestra explícitamente el tamaño de la muestra; por lo tanto, puede ser útil complementarlo con anotaciones o variando el ancho de las cajas.\n\nEl boxplot oculta la forma exacta de la distribución. Para conjuntos pequeños de datos puede complementarse con puntos dispersos (jitter), y en casos generales, con un gráfico tipo violin que muestre la densidad de los valores.\n\nNo ordenar los boxplots por mediana al comparar varios grupos puede dificultar la interpretación de patrones."
  },
  {
    "objectID": "posts/circularPacking/circularPacking.html",
    "href": "posts/circularPacking/circularPacking.html",
    "title": "Circular Packing",
    "section": "",
    "text": "Representa estructuras jerárquicas mediante círculos en donde cada nodo se muestra como un círculo y sus subnodos aparecen dentro de él. El área de cada círculo puede ser proporcional a un valor numérico (por ejemplo: población, ventas, ingresos). Utiliza menos eficientemente el espacio que un treemap, pero ofrece una representación visual más estética y clara de las jerarquías. Se puede mostrar la jerarquía completa o eliminar niveles iniciales para mejorar la legibilidad."
  },
  {
    "objectID": "posts/circularPacking/circularPacking.html#cuándo-usarlo",
    "href": "posts/circularPacking/circularPacking.html#cuándo-usarlo",
    "title": "Circular Packing",
    "section": "Cuándo usarlo",
    "text": "Cuándo usarlo\n\nCuando se desea resaltar la estructura jerárquica de los datos.\nEn casos donde lo importante es la organización de grupos y subgrupos, no la comparación exacta de valores.\nPara visualizaciones interactivas que permitan explorar los niveles de detalle."
  },
  {
    "objectID": "posts/circularPacking/circularPacking.html#errores-comunes-a-evitar",
    "href": "posts/circularPacking/circularPacking.html#errores-comunes-a-evitar",
    "title": "Circular Packing",
    "section": "Errores comunes a evitar",
    "text": "Errores comunes a evitar\n\nIncluir demasiados niveles jerárquicos en una sola vista\nEsto produce un gráfico saturado y difícil de leer.\nSolución: usar versiones interactivas o limitar el número de niveles.\nPretender comparar valores con precisión\nEl área de los círculos no se percibe con exactitud a simple vista.\nSolución: si se requiere precisión, emplear gráficos de barras o de puntos.\nSobrecargar con etiquetas\nMuchas etiquetas dificultan la lectura del gráfico.\nSolución: mostrar solo etiquetas clave o habilitar interacción con hover.\nEscalado inadecuado de los tamaños\nSi los valores son muy dispares, algunos círculos pueden resultar invisibles.\nSolución: aplicar transformaciones (logarítmica, raíz cuadrada) o segmentar los datos.\nUsarlo como herramienta de comparación exacta\nEste gráfico está diseñado para mostrar jerarquías, no para análisis cuantitativos precisos."
  },
  {
    "objectID": "posts/circularPacking/circularPacking.html#visualización-circle-packing",
    "href": "posts/circularPacking/circularPacking.html#visualización-circle-packing",
    "title": "Circular Packing",
    "section": "Visualización Circle Packing",
    "text": "Visualización Circle Packing"
  },
  {
    "objectID": "posts/densidad/densidad.html",
    "href": "posts/densidad/densidad.html",
    "title": "Gráfico de Densidad",
    "section": "",
    "text": "Un gráfico de densidad es una representación de la distribución de una variable numérica.\nSe basa en un estimador de densidad kernel (KDE) para mostrar la función de densidad de probabilidad de la variable.\nEs una versión suavizada del histograma y se utiliza en los mismos contextos."
  },
  {
    "objectID": "posts/densidad/densidad.html#gráfico-de-densidad",
    "href": "posts/densidad/densidad.html#gráfico-de-densidad",
    "title": "Gráfico de Densidad",
    "section": "0.1 ",
    "text": "0.1"
  },
  {
    "objectID": "posts/densidad/densidad.html#características",
    "href": "posts/densidad/densidad.html#características",
    "title": "Gráfico de Densidad",
    "section": "0.2 Características",
    "text": "0.2 Características\nLos gráficos de densidad se usan para analizar la distribución de una o pocas variables.\nRevisar la distribución de tus variables es probablemente la primera tarea exploratoria al trabajar con un nuevo dataset, pues entrega mucha información sobre los datos.\nExisten múltiples formas de distribución: simétrica, sesgada a la derecha o izquierda, multimodal, uniforme, etc.\nExplorarlas también ayuda a detectar errores en los datos, como distribuciones en “peine” que suelen indicar redondeo o algún procesamiento inadecuado.\nPara comparar variables: - 1 a 3 distribuciones se pueden mostrar en el mismo gráfico usando transparencia.\n- Con más de 3, el gráfico se vuelve ilegible → en este caso es mejor usar violin plots, boxplots, ridgeline plots o small multiples."
  },
  {
    "objectID": "posts/densidad/densidad.html#errores-comunes",
    "href": "posts/densidad/densidad.html#errores-comunes",
    "title": "Gráfico de Densidad",
    "section": "0.3 Errores Comunes",
    "text": "0.3 Errores Comunes\n\nNo ajustar el parámetro de ancho de banda (bandwidth):\nDependiendo del valor, la curva puede ocultar detalles (suavizado excesivo) o mostrar demasiado ruido (suavizado insuficiente).\nComparar demasiados grupos en un solo gráfico:\nMás de 3 o 4 curvas superpuestas generan un gráfico confuso.\nUso excesivo de colores:\nPaletas muy variadas distraen. Mejor usar colores simples y bien diferenciados."
  },
  {
    "objectID": "posts/folium/folium.html",
    "href": "posts/folium/folium.html",
    "title": "Mapa de Color",
    "section": "",
    "text": "Objetivo: Desarrollar una infografia georeferenciada de las votaciones del Ecuador del año del 2002."
  },
  {
    "objectID": "posts/folium/folium.html#etl-del-dataset",
    "href": "posts/folium/folium.html#etl-del-dataset",
    "title": "Mapa de Color",
    "section": "ETL del dataset",
    "text": "ETL del dataset\n\ndf = pd.read_csv(\"presidentes_votacion_cantonal_formato_angosto.csv\")\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 77462 entries, 0 to 77461\nData columns (total 9 columns):\n #   Column            Non-Null Count  Dtype \n---  ------            --------------  ----- \n 0   ANIO              77462 non-null  int64 \n 1   VUELTA            77462 non-null  int64 \n 2   PROVINCIA_CODIGO  77462 non-null  object\n 3   PROVINCIA_NOMBRE  77462 non-null  object\n 4   CANTON_CODIGO     77462 non-null  object\n 5   CANTON_NOMBRE     77462 non-null  object\n 6   CANDIDATO_NOMBRE  77462 non-null  object\n 7   AGRUPACION        77462 non-null  object\n 8   VOTOS             77462 non-null  int64 \ndtypes: int64(3), object(6)\nmemory usage: 5.3+ MB\n\n\n\ndf.head()\n\n\n\n\n\n\n\n\nANIO\nVUELTA\nPROVINCIA_CODIGO\nPROVINCIA_NOMBRE\nCANTON_CODIGO\nCANTON_NOMBRE\nCANDIDATO_NOMBRE\nAGRUPACION\nVOTOS\n\n\n\n\n0\n2002\n1\nEC01\nAZUAY\nEC0101\nCUENCA\nALVARO NOBOA\nF\n7463\n\n\n1\n2002\n1\nEC01\nAZUAY\nEC0101\nCUENCA\nALVARO NOBOA\nM\n6950\n\n\n2\n2002\n1\nEC01\nAZUAY\nEC0101\nCUENCA\nALVARO NOBOA\nT\n14413\n\n\n3\n2002\n1\nEC01\nAZUAY\nEC0101\nCUENCA\nANTONIO VARGAS\nF\n448\n\n\n4\n2002\n1\nEC01\nAZUAY\nEC0101\nCUENCA\nANTONIO VARGAS\nM\n444\n\n\n\n\n\n\n\n\n# agrupacion para obtener valos por provincia\ndf_gr = df.groupby([\"ANIO\", \"VUELTA\", \"PROVINCIA_NOMBRE\",\"CANDIDATO_NOMBRE\",\"PROVINCIA_CODIGO\"])[\"VOTOS\"].sum().reset_index()\n# solo datos de Ecuador continental \ndf_gr = df_gr[~df_gr[\"PROVINCIA_NOMBRE\"].isin(['EUROPA, ASIA, OCEANIA', 'NORTE-AMERICA', 'LATAM, CARIBE, AFRICA'])]\n# AGRUPACION DEL 2002 Y VUELTA 1\ndf_gr_02 = df_gr.query(\"ANIO == 2002 & VUELTA == 1\")\n# CANDIDATOS seleccionados de la grafica\nfiltroCandidatos = ['ALVARO NOBOA',  'JACOBO BUCARAM','LUCIO GUTIERREZ', \n                     'RODRIGO BORJA','XAVIER NEIRA']\ndf_gr_02 = df_gr_02[df_gr_02.CANDIDATO_NOMBRE.isin(filtroCandidatos)]\n# agrupacion por voto mayoritario en provinica\ndf_max = df_gr_02.loc[\n    df_gr_02.groupby('PROVINCIA_NOMBRE')['VOTOS'].idxmax()\n]\n\n\ndf_max.head()\n\n\n\n\n\n\n\n\nANIO\nVUELTA\nPROVINCIA_NOMBRE\nCANDIDATO_NOMBRE\nPROVINCIA_CODIGO\nVOTOS\n\n\n\n\n10\n2002\n1\nAZUAY\nRODRIGO BORJA\nEC01\n157246\n\n\n19\n2002\n1\nBOLIVAR\nLUCIO GUTIERREZ\nEC02\n45850\n\n\n31\n2002\n1\nCANAR\nLUCIO GUTIERREZ\nEC03\n45386\n\n\n36\n2002\n1\nCARCHI\nALVARO NOBOA\nEC04\n41330\n\n\n55\n2002\n1\nCHIMBORAZO\nLUCIO GUTIERREZ\nEC06\n114652"
  },
  {
    "objectID": "posts/folium/folium.html#manejo-del-archivo-.json",
    "href": "posts/folium/folium.html#manejo-del-archivo-.json",
    "title": "Mapa de Color",
    "section": "Manejo del archivo .json",
    "text": "Manejo del archivo .json\n\n# Load Ecuador's GeoJSON data\nwith open(\"ecuador_provincias.json\", \"r\", encoding=\"utf-8\") as f:\n    geo_json_data = json.load(f)\ndf_max.PROVINCIA_NOMBRE.unique()\n\narray(['AZUAY', 'BOLIVAR', 'CANAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI',\n       'EL ORO', 'ESMERALDAS', 'GALAPAGOS', 'GUAYAS', 'IMBABURA', 'LOJA',\n       'LOS RIOS', 'MANABI', 'MORONA SANTIAGO', 'NAPO', 'ORELLANA',\n       'PASTAZA', 'PICHINCHA', 'SANTA ELENA', 'STO DGO TSACHILAS',\n       'SUCUMBIOS', 'TUNGURAHUA', 'ZAMORA CHINCHIPE'], dtype=object)\n\n\n\n# Nombre de la provincias \nnombresGjson = sorted([x['properties'][\"name\"].upper() for x in geo_json_data['features']])\n# nombres a cambiar CAÑAR ,'SANTO DOMINGO DE LOS TSÁCHILAS' cambio en el dataset\ndf_max[\"PROVINCIA_NOMBRE\"] = df_max[\"PROVINCIA_NOMBRE\"].replace({'CANAR':'CAÑAR',\n                        'STO DGO TSACHILAS':'SANTO DOMINGO DE LOS TSÁCHILAS'})\ndf_max[\"PROVINCIA_NOMBRE\"].unique()\n\narray(['AZUAY', 'BOLIVAR', 'CAÑAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI',\n       'EL ORO', 'ESMERALDAS', 'GALAPAGOS', 'GUAYAS', 'IMBABURA', 'LOJA',\n       'LOS RIOS', 'MANABI', 'MORONA SANTIAGO', 'NAPO', 'ORELLANA',\n       'PASTAZA', 'PICHINCHA', 'SANTA ELENA',\n       'SANTO DOMINGO DE LOS TSÁCHILAS', 'SUCUMBIOS', 'TUNGURAHUA',\n       'ZAMORA CHINCHIPE'], dtype=object)"
  },
  {
    "objectID": "posts/folium/folium.html#estilo-del-mapa",
    "href": "posts/folium/folium.html#estilo-del-mapa",
    "title": "Mapa de Color",
    "section": "Estilo del Mapa",
    "text": "Estilo del Mapa\n\n# COLORES POR CANDIDATO\nmapa_colores ={'ALVARO NOBOA':\"#980BEF\", 'JACOBO BUCARAM':\"#1070B9\", 'LUCIO GUTIERREZ':\"#E01212\",\n       'RODRIGO BORJA':\"#FEB00A\", 'XAVIER NEIRA':\"#F6FE69\"}\n# aplicar color al dataset\ndf_max['COLOR'] = df_max['CANDIDATO_NOMBRE'].apply(lambda x:mapa_colores.get(x))\ndf_max.head()\n\n\n\n\n\n\n\n\nANIO\nVUELTA\nPROVINCIA_NOMBRE\nCANDIDATO_NOMBRE\nPROVINCIA_CODIGO\nVOTOS\nCOLOR\n\n\n\n\n10\n2002\n1\nAZUAY\nRODRIGO BORJA\nEC01\n157246\n#FEB00A\n\n\n19\n2002\n1\nBOLIVAR\nLUCIO GUTIERREZ\nEC02\n45850\n#E01212\n\n\n31\n2002\n1\nCAÑAR\nLUCIO GUTIERREZ\nEC03\n45386\n#E01212\n\n\n36\n2002\n1\nCARCHI\nALVARO NOBOA\nEC04\n41330\n#980BEF\n\n\n55\n2002\n1\nCHIMBORAZO\nLUCIO GUTIERREZ\nEC06\n114652\n#E01212\n\n\n\n\n\n\n\n\n# OBJETIVO TENER UN COLOR POR PROVINICA PARA EL MAPA EN ESTE CASO UN DICT\ncolor_provincia = (\n    df_max.drop_duplicates('PROVINCIA_NOMBRE')\n         .set_index('PROVINCIA_NOMBRE')['COLOR']\n         .to_dict()\n)\n# OBJETIVO TENER Nombre candidato\ncandidatoNombre = (\n    df_max.drop_duplicates('PROVINCIA_NOMBRE')\n         .set_index('PROVINCIA_NOMBRE')['CANDIDATO_NOMBRE']\n         .to_dict()\n)\n\n\ncolor_provincia\n\n{'AZUAY': '#FEB00A',\n 'BOLIVAR': '#E01212',\n 'CAÑAR': '#E01212',\n 'CARCHI': '#980BEF',\n 'CHIMBORAZO': '#E01212',\n 'COTOPAXI': '#E01212',\n 'EL ORO': '#E01212',\n 'ESMERALDAS': '#1070B9',\n 'GALAPAGOS': '#980BEF',\n 'GUAYAS': '#F6FE69',\n 'IMBABURA': '#E01212',\n 'LOJA': '#E01212',\n 'LOS RIOS': '#1070B9',\n 'MANABI': '#980BEF',\n 'MORONA SANTIAGO': '#E01212',\n 'NAPO': '#E01212',\n 'ORELLANA': '#E01212',\n 'PASTAZA': '#E01212',\n 'PICHINCHA': '#FEB00A',\n 'SANTA ELENA': '#980BEF',\n 'SANTO DOMINGO DE LOS TSÁCHILAS': '#E01212',\n 'SUCUMBIOS': '#E01212',\n 'TUNGURAHUA': '#E01212',\n 'ZAMORA CHINCHIPE': '#E01212'}\n\n\n\nm = folium.Map(\n    [-0.19899731681836336, -78.4428000494774], # PUNTO INICIAL\n    tiles=\"Cartodb dark_matter\" ,# TIPO DE ESTILO DE MAPA\n    zoom_start=5) # ZOOM INICIAL\n# LECTURA DEL geo_json_data OBJETO\nfolium.GeoJson(\n    geo_json_data,\n    style_function=lambda feature: {\n        \"fillColor\": color_provincia.get(feature[\"properties\"][\"name\"].upper(), \"#808080\"),\n        \"color\": \"black\",\n        \"fillOpacity\": 0.8,\n    },\n    tooltip=folium.GeoJsonTooltip(\n            fields=[\"name\"],\n            aliases=[\"Provincia:\"]\n        )\n).add_to(m)\n# save del archivo\nm.save(\"VotEcuador2002V1.html\")\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\n\n\n\n# Generamos dinámicamente los ítems de la leyenda\nitems_html = \"\"\nfor candidato, color in mapa_colores.items():\n    items_html += f'''\n    &nbsp; &lt;i class=\"fa fa-square\" style=\"color:{color}\"&gt;&lt;/i&gt;\n    &nbsp; {candidato} &lt;br&gt;'''\n\n# HTML completo para la leyenda\nlegend_html = f'''\n{{% macro html(this, kwargs) %}}\n&lt;div style=\"position: fixed; \n     bottom: 50px; left: 50px; width: 250px; \n     border:2px solid grey; z-index:9999; font-size:14px;\n     background-color:white; opacity: 0.9;\n     padding: 10px; border-radius: 5px\"&gt;\n     &lt;b&gt;🗳️ Candidato ganador&lt;/b&gt;&lt;br&gt;\n     {items_html}\n&lt;/div&gt;\n{{% endmacro %}}\n'''\n\n# Añadimos la leyenda al mapa\nlegend = branca.element.MacroElement()\nlegend._template = branca.element.Template(legend_html)\nm.get_root().add_child(legend)\n\n# Guardar y mostrar\nm.save('VotEcuador2002V1Legend.html')\n\n\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/GLineas/graficoLineas.html",
    "href": "posts/GLineas/graficoLineas.html",
    "title": "Gráfico de Lineas",
    "section": "",
    "text": "Un gráfico de líneas muestra la evolución de una o varias variables numéricas a lo largo del tiempo u otro eje ordenado. Los puntos de datos se conectan mediante segmentos rectos, lo que facilita identificar tendencias, picos y caídas."
  },
  {
    "objectID": "posts/GLineas/graficoLineas.html#cuándo-usarlo",
    "href": "posts/GLineas/graficoLineas.html#cuándo-usarlo",
    "title": "Gráfico de Lineas",
    "section": "0.1 ¿Cuándo usarlo?",
    "text": "0.1 ¿Cuándo usarlo?\n\nSeries temporales (ejemplo: temperatura diaria, ventas mensuales, número de usuarios por semana).\nComparar la evolución de varias categorías, siempre que no haya demasiadas líneas.\n\nDetectar patrones, ciclos o cambios significativos en el tiempo."
  },
  {
    "objectID": "posts/GLineas/graficoLineas.html#características-clave",
    "href": "posts/GLineas/graficoLineas.html#características-clave",
    "title": "Gráfico de Lineas",
    "section": "0.2 Características clave",
    "text": "0.2 Características clave\n\nEje X: variable ordenada (generalmente el tiempo).\n\nEje Y: magnitudes numéricas.\n\nLos datos están ordenados y unidos por líneas, a diferencia del gráfico de dispersión donde los puntos aparecen aislados.\n\nPuede incluir una zona de confianza alrededor de la línea cuando se trabaja con valores promediados."
  },
  {
    "objectID": "posts/GLineas/graficoLineas.html#errores-a-evitar",
    "href": "posts/GLineas/graficoLineas.html#errores-a-evitar",
    "title": "Gráfico de Lineas",
    "section": "0.3 Errores a evitar",
    "text": "0.3 Errores a evitar\n\nCortar el eje Y sin justificación: exagera o minimiza cambios.\n\nUsar doble eje Y: confunde al lector.\n\nGráfico espagueti: demasiadas líneas hacen ilegible el gráfico."
  },
  {
    "objectID": "posts/Histograma/histograma.html",
    "href": "posts/Histograma/histograma.html",
    "title": "Histograma",
    "section": "",
    "text": "Un histograma es una representación gráfica de la distribución de un conjunto de datos.\nSe construye dividiendo los datos en intervalos (bins) y mostrando en el eje Y la frecuencia con que los valores caen en cada intervalo."
  },
  {
    "objectID": "posts/Histograma/histograma.html#caracteristicas",
    "href": "posts/Histograma/histograma.html#caracteristicas",
    "title": "Histograma",
    "section": "0.1 Caracteristicas",
    "text": "0.1 Caracteristicas\n\nResumir grandes volúmenes de datos permite visualizar rápidamente la distribución.\n\nDetectar valores atípicos identificar datos que se desvían del comportamiento general.\n\nComprender patrones:\n\nAsimetría de la distribución.\n\nModa (cantidad de picos).\n\nDispersión (rango de los datos).\n\n\nComparar conjuntos de datos colocando histogramas lado a lado."
  },
  {
    "objectID": "posts/Histograma/histograma.html#cálculo-de-los-bins-intervalos",
    "href": "posts/Histograma/histograma.html#cálculo-de-los-bins-intervalos",
    "title": "Histograma",
    "section": "0.2 Cálculo de los Bins (Intervalos)",
    "text": "0.2 Cálculo de los Bins (Intervalos)\nExisten reglas prácticas para determinar el número de bins:\n\nRegla de la raíz cuadrada\n\\[\nk \\approx \\sqrt{n}\n\\]\nRegla de Sturges\n\\[\nk \\approx 1 + \\log_{2}(n)\n\\]\n\nLa mejor elección depende del tamaño del dataset y de la distribución de los datos."
  },
  {
    "objectID": "posts/Histograma/histograma.html#errores-comunes-y-cómo-evitarlos",
    "href": "posts/Histograma/histograma.html#errores-comunes-y-cómo-evitarlos",
    "title": "Histograma",
    "section": "0.3 Errores Comunes y Cómo Evitarlos",
    "text": "0.3 Errores Comunes y Cómo Evitarlos\n\nElegir bins inadecuados\n\nBins demasiado anchos pierdes detalle.\n\nBins demasiado estrechos ruido excesivo.\n\nEscalas y etiquetas incorrectas\n\nEjes sin unidades o mal definidos dificulta interpretación.\n\nEscalas distintas al comparar histogramas comparaciones engañosas.\n\nExcluir valores atípicos sin justificación\n\nOculta información importante sobre la distribución."
  },
  {
    "objectID": "posts/Isotype/Isotype.html",
    "href": "posts/Isotype/Isotype.html",
    "title": "Isotype",
    "section": "",
    "text": "ISOTYPE (International System of Typographic Picture Education) fue creado en los años 1920 por Otto Neurath.\n\nTambién conocido como el método de Viena.\n\nPropone comunicar información compleja mediante pictogramas e iconos, con el mínimo de texto.\n\nPrincipio clave: “las palabras separan, las imágenes unen”."
  },
  {
    "objectID": "posts/Isotype/Isotype.html#características",
    "href": "posts/Isotype/Isotype.html#características",
    "title": "Isotype",
    "section": "0.1 Características",
    "text": "0.1 Características\n\nUso de pictogramas simples y gráficos elementales.\n\nLenguaje visual universal, independiente de idiomas.\n\nInspirado en el funcionalismo gráfico de la Bauhaus y las vanguardias del siglo XX.\n\nLa comprensión se logra en tres pasos: captar lo esencial, lo secundario y los detalles.\n\nVisualización de datos estadísticos: tablas y gráficos comparativos.\n\nEducación y divulgación: explicar fenómenos sociales, económicos o históricos.\n\nDiseño gráfico y editorial: base de la infografía moderna."
  },
  {
    "objectID": "posts/Isotype/Isotype.html#errores-a-evitar",
    "href": "posts/Isotype/Isotype.html#errores-a-evitar",
    "title": "Isotype",
    "section": "0.2 Errores a Evitar",
    "text": "0.2 Errores a Evitar\n\nEscalar pictogramas para “mostrar más” (tamaño ≠ cantidad); en Isotype se repiten iconos del mismo tamaño.\nNo definir la unidad visual: falta de leyenda “1 icono = N unidades”.\nIconografía inconsistente: cambiar de pictograma para la misma categoría.\nEfectos decorativos (3D, degradados, sombras) que restan legibilidad.\nIconos culturalmente ambiguos: metáforas no universales."
  },
  {
    "objectID": "posts/Isotype/Isotype.html#usos-principales",
    "href": "posts/Isotype/Isotype.html#usos-principales",
    "title": "Isotype",
    "section": "1.1 Usos principales",
    "text": "1.1 Usos principales\n\nExploración de datos de manera visual y rápida.\n\nCreación de gráficos interactivos en notebooks, aplicaciones web y dashboards.\n\nInformes y storytelling con datos, gracias a su integración con Jupyter, Streamlit, Panel y Quarto."
  },
  {
    "objectID": "posts/Isotype/Isotype.html#características-principales",
    "href": "posts/Isotype/Isotype.html#características-principales",
    "title": "Isotype",
    "section": "1.2 Características principales",
    "text": "1.2 Características principales\n\nSintaxis declarativa y concisa: describes el gráfico indicando las columnas de tus datos y el tipo de marca (barras, puntos, líneas, etc.).\n\nAdmite interactividad integrada como zoom, selección y filtrado.\n\nCompatible con pandas DataFrames y librerías de análisis como NumPy.\n\nExporta visualizaciones en formato JSON para reproducibilidad."
  },
  {
    "objectID": "posts/Isotype/Isotype.html#instalación",
    "href": "posts/Isotype/Isotype.html#instalación",
    "title": "Isotype",
    "section": "1.3 Instalación",
    "text": "1.3 Instalación\nPara instalar Altair y sus dependencias más comunes:\npip install \"altair[all]\"\n\n\n# Dataset: Base de Artículos Publicados 2015–2023\n\n**Fuente:**  \n[Secretaría de Educación Superior, Ciencia, Tecnología e Innovación (SENESCYT)](https://cloud-pro.senescyt.gob.ec/index.php/s/qfDbtQxawojJ2CG?openfile=true)\n\n**Descripción:**  \nEste dataset contiene la base estadística de artículos científicos publicados por las universidades y escuelas politécnicas de Ecuador en **revistas indexadas** durante el periodo **2015 – 2023**.  \n\n::: {#20c93db1 .cell execution_count=30}\n``` {.python .cell-code}\nimport pandas as pd\nfrom wordcloud import WordCloud, STOPWORDS\nimport matplotlib.pyplot as plt\ndf = pd.read_excel(\"Base_estadistica_articulos_UEP_15_23.xlsx\", skiprows=12)\n:::\n\nimport pandas as pd\nimport numpy as np\nimport altair as alt\n\n# ---- Filtrar y calcular top 10 ----\ndf_filtered = df[df['NOMBRE UNIVERSIDAD'] == \"UNIVERSIDAD SAN FRANCISCO DE QUITO\"][\"CAMPO DETALLADO\"].dropna().astype(str)\ntop = df_filtered.value_counts().head(10).reset_index()\ntop.columns = [\"CAMPO DETALLADO\", \"FRECUENCIA\"]\n\n# ---- Parámetros del isotype ----\nUNIDAD = 50  # 1 ícono = 50 publicaciones\n\n# Emojis por categoría (puedes ajustar a gusto)\nemoji_map = {\n    \"FÍSICA\": \"🔭\",\n    \"MEDICINA\": \"💊\",\n    \"BIOLOGÍA\": \"🧬\",\n    \"MEDIO AMBIENTE\": \"🌱\",\n    \"ESTUDIOS SOCIALES Y CULTURALES\": \"📚\",\n    \"CONSTRUCCIÓN E INGENIERÍA CIVIL\": \"🏗️\",\n    \"BIOMEDICINA\": \"🧪\",\n    \"SALUD PÚBLICA\": \"🏥\",\n    \"COMPUTACIÓN\": \"💻\",\n    \"QUÍMICA\": \"⚗️\"\n}\n\n# Calcular número de iconos\ntop[\"ICONOS\"] = np.maximum((top[\"FRECUENCIA\"] // UNIDAD).astype(int), 1)\n\n# Expandir filas: una por ícono\nrows = []\nfor _, r in top.iterrows():\n    for i in range(int(r[\"ICONOS\"])):\n        rows.append({\n            \"CAMPO DETALLADO\": r[\"CAMPO DETALLADO\"],\n            \"y\": i  # eje vertical\n        })\n\nsource = pd.DataFrame(rows)\n\n# Gráfico vertical\nchart = (\n    alt.Chart(source)\n    .mark_text(size=25, baseline='middle')\n    .encode(\n        alt.X('CAMPO DETALLADO:O', sort=top[\"CAMPO DETALLADO\"].tolist()).axis(None),\n        alt.Y('y:O').axis(None),\n        alt.Text('emoji:N')\n    )\n    .transform_calculate(\n        emoji=f\"{emoji_map}\".replace(\"'\", '\"') + \"[datum['CAMPO DETALLADO']]\"\n    )\n    .properties(width=650, height=500)\n)\n\n# Pie con la equivalencia\nnota = alt.Chart(pd.DataFrame({\"t\": [f\"1 icono = {UNIDAD} publicaciones\"]})).mark_text(\n    align=\"left\", dx=5, dy=15\n).encode(text=\"t:N\")\n\nchart & nota\n\nc:\\Users\\meagu\\anaconda3\\Lib\\site-packages\\altair\\utils\\core.py:395: FutureWarning: the convert_dtype parameter is deprecated and will be removed in a future version.  Do ``ser.astype(object).apply()`` instead if you want ``convert_dtype=False``.\n  col = df[col_name].apply(to_list_if_array, convert_dtype=False)\nc:\\Users\\meagu\\anaconda3\\Lib\\site-packages\\altair\\utils\\core.py:395: FutureWarning: the convert_dtype parameter is deprecated and will be removed in a future version.  Do ``ser.astype(object).apply()`` instead if you want ``convert_dtype=False``.\n  col = df[col_name].apply(to_list_if_array, convert_dtype=False)"
  },
  {
    "objectID": "posts/Isotype/Isotype.html#iteración-2",
    "href": "posts/Isotype/Isotype.html#iteración-2",
    "title": "Isotype",
    "section": "1.4 Iteración 2",
    "text": "1.4 Iteración 2\n\nimport pandas as pd\nimport numpy as np\nimport altair as alt\n\n# ---- Filtrar y calcular top 10 ----\ndf_filtered = df[df['NOMBRE UNIVERSIDAD'] == \"UNIVERSIDAD SAN FRANCISCO DE QUITO\"][\"CAMPO DETALLADO\"].dropna().astype(str)\ntop = df_filtered.value_counts().head(10).reset_index()\ntop.columns = [\"CAMPO DETALLADO\", \"FRECUENCIA\"]\n\n# ---- Parámetros del isotype ----\nUNIDAD = 50  # 1 ícono = 50 publicaciones\n\n# Emojis por categoría\nemoji_map = {\n    \"FÍSICA\": \"🔭\",\n    \"MEDICINA\": \"💊\",\n    \"BIOLOGÍA\": \"🧬\",\n    \"MEDIO AMBIENTE\": \"🌱\",\n    \"ESTUDIOS SOCIALES Y CULTURALES\": \"📚\",\n    \"CONSTRUCCIÓN E INGENIERÍA CIVIL\": \"🏗️\",\n    \"BIOMEDICINA\": \"🧪\",\n    \"SALUD PÚBLICA\": \"🏥\",\n    \"COMPUTACIÓN\": \"💻\",\n    \"QUÍMICA\": \"⚗️\"\n}\n\n# Calcular número de iconos\ntop[\"ICONOS\"] = np.maximum((top[\"FRECUENCIA\"] // UNIDAD).astype(int), 1)\n\n# Expandir filas: una por ícono\nrows = []\nfor _, r in top.iterrows():\n    for i in range(int(r[\"ICONOS\"])):\n        rows.append({\n            \"CAMPO DETALLADO\": r[\"CAMPO DETALLADO\"],\n            \"x\": i  # eje horizontal\n        })\n\nsource = pd.DataFrame(rows)\n\n# Gráfico horizontal con eje X\nchart = (\n    alt.Chart(source)\n    .mark_text(size=25, baseline='middle')\n    .encode(\n        alt.X('x:O', axis=alt.Axis(title=f\"Número de íconos (1 = {UNIDAD} publicaciones)\")),\n        alt.Y('CAMPO DETALLADO:O', sort=top[\"CAMPO DETALLADO\"].tolist()),\n        alt.Text('emoji:N')\n    )\n    .transform_calculate(\n        emoji=f\"{emoji_map}\".replace(\"'\", '\"') + \"[datum['CAMPO DETALLADO']]\"\n    )\n    .properties(width=800, height=400)\n)\n\nchart\n\nc:\\Users\\meagu\\anaconda3\\Lib\\site-packages\\altair\\utils\\core.py:395: FutureWarning: the convert_dtype parameter is deprecated and will be removed in a future version.  Do ``ser.astype(object).apply()`` instead if you want ``convert_dtype=False``.\n  col = df[col_name].apply(to_list_if_array, convert_dtype=False)"
  },
  {
    "objectID": "posts/Isotype/Isotype.html#iteración-3",
    "href": "posts/Isotype/Isotype.html#iteración-3",
    "title": "Isotype",
    "section": "1.5 Iteración 3",
    "text": "1.5 Iteración 3\n\n# Gráfico horizontal SIN eje X y SIN líneas\nchart = (\n    alt.Chart(source)\n    .mark_text(size=25, baseline='middle')\n    .encode(\n        alt.X('x:O', axis=None),   # ❌ elimina por completo el eje X\n        alt.Y(\n            'CAMPO DETALLADO:O',\n            sort=top[\"CAMPO DETALLADO\"].tolist(),\n            axis=alt.Axis(ticks=False, domain=False, grid=False)\n        ),\n        alt.Text('emoji:N')\n    )\n    .transform_calculate(\n        emoji=f\"{emoji_map}\".replace(\"'\", '\"') + \"[datum['CAMPO DETALLADO']]\"\n    )\n    .properties(width=800, height=400)\n)\n\nchart\n\nc:\\Users\\meagu\\anaconda3\\Lib\\site-packages\\altair\\utils\\core.py:395: FutureWarning: the convert_dtype parameter is deprecated and will be removed in a future version.  Do ``ser.astype(object).apply()`` instead if you want ``convert_dtype=False``.\n  col = df[col_name].apply(to_list_if_array, convert_dtype=False)\n\n\n\n\n\n\n\n\n\n# Gráfico horizontal SIN eje X y SIN nombre/líneas en el eje Y\nchart = (\n    alt.Chart(source)\n    .mark_text(size=25, baseline='middle')\n    .encode(\n        alt.X('x:O', axis=None),  # ❌ elimina el eje X completo\n        alt.Y(\n            'CAMPO DETALLADO:O',\n            sort=top[\"CAMPO DETALLADO\"].tolist(),\n            axis=alt.Axis(\n                ticks=False,\n                domain=False,\n                grid=False,\n                title=None   # ❌ sin nombre del eje Y\n            )\n        ),\n        alt.Text('emoji:N')\n    )\n    .transform_calculate(\n        emoji=f\"{emoji_map}\".replace(\"'\", '\"') + \"[datum['CAMPO DETALLADO']]\"\n    )\n    .properties(width=800, height=400)\n)\n\nchart\n\nc:\\Users\\meagu\\anaconda3\\Lib\\site-packages\\altair\\utils\\core.py:395: FutureWarning: the convert_dtype parameter is deprecated and will be removed in a future version.  Do ``ser.astype(object).apply()`` instead if you want ``convert_dtype=False``.\n  col = df[col_name].apply(to_list_if_array, convert_dtype=False)"
  },
  {
    "objectID": "posts/Mapa2/mapa2.html",
    "href": "posts/Mapa2/mapa2.html",
    "title": "folium points",
    "section": "",
    "text": "import pandas as pd\n\n\ndf= pd.read_excel(\"mapaPatricion.xlsx\", skiprows=1)\n\ndf.head()\n\n\n\n\n\n\n\n\nb. NOMBRE DEL CENTRO DE FAENAMIENTO\na. X\nb. Y\nc. Z\n\n\n\n\n0\nCENTRO DE FAENAMIENTO EMPRESA MUNICIPAL DE SER...\n724495.0\n9683113.0\n2538\n\n\n1\nCENTRO DE FAENAMIENTO DEL GAD MUNICIPAL DE GUA...\n747612.0\n9680341.0\n2228\n\n\n2\nCENTRO DE FAENAMIENTO DEL GAD MUNICIPAL DEL SI...\n721314.0\n9662528.0\n2788\n\n\n3\nCENTRO DE FAENAMIENTO DEL GAD MUNICIPAL DE PAUTE\n750021.0\n9693269.0\n2173\n\n\n4\nCENTRO DE FAENAMIENTO DEL GAD MUNICIPAL PUCARÁ\n670274.0\n9643909.0\n3100\n\n\n\n\n\n\n\n\ndf.columns\n\nIndex(['b. NOMBRE DEL CENTRO DE FAENAMIENTO', 'a. X', 'b. Y', 'c. Z'], dtype='object')\n\n\n\nimport pandas as pd\nfrom pyproj import Transformer\n\ndef infer_zona_utm(x):\n    if 166000 &lt;= x &lt;= 833000:\n        return 17\n    elif 833000 &lt; x &lt;= 1660000:  # No aplica a Ecuador\n        return 18\n    else:\n        return 17  # Valor por defecto\n\ndef utm_to_latlon_auto(row):\n    zona = infer_zona_utm(row['a. X'])\n    epsg_utm = f\"EPSG:327{zona}\"\n    transformer = Transformer.from_crs(epsg_utm, \"EPSG:4326\", always_xy=True)\n    lon, lat = transformer.transform(row['a. X'], row['b. Y'])\n    return pd.Series({'LATITUD': lat, 'LONGITUD': lon, 'ZONA_UTM': zona})\n\ndf[['LATITUD', 'LONGITUD', 'ZONA_UTM']] = df.apply(utm_to_latlon_auto, axis=1)\n\n\nimport folium\nimport pandas as pd\n\n# Example dataframe\n\n\n# Create a Folium map centered around Ecuador\nm = folium.Map(location=[-2.8, -78.9], zoom_start=8)\n\n# Add markers\nfor _, row in df.iterrows():\n    folium.Marker(\n        location=[row['LATITUD'], row['LONGITUD']],\n        popup=f\"{row['b. NOMBRE DEL CENTRO DE FAENAMIENTO']}&lt;br&gt;Altitud: {row['LONGITUD']} m\",\n        icon=folium.Icon()\n    ).add_to(m)\n\n# Save map\nmap_path = \"mapa_faenamiento.html\"\nm.save(map_path)\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html",
    "href": "posts/MapEcuador/folium_timeline.html",
    "title": "Time Map",
    "section": "",
    "text": "The dataset was obtained from the USFQ Data Hub and from the following source:\nObjective:\nDevelop a georeferenced infographic that visualizes the voting results of the 2002 Ecuadorian presidential elections in Ecuador.\nimport folium\nimport pandas as pd\nimport geopandas as gpd\nimport branca\nimport json\nfrom folium.plugins import TimestampedGeoJson"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#handling-json-with-geopandas",
    "href": "posts/MapEcuador/folium_timeline.html#handling-json-with-geopandas",
    "title": "Time Map",
    "section": "Handling JSON with GeoPandas",
    "text": "Handling JSON with GeoPandas\n\ndf_ecu = gpd.read_file(\"ecuador_provincias.json\")\ndf_ecu[\"name\"] = df_ecu[\"name\"].str.upper()\ndf_ecu.head()\n\n\n\n\n\n\n\n\nsource\nid\nname\ngeometry\n\n\n\n\n0\nhttps://simplemaps.com\nECE\nESMERALDAS\nMULTIPOLYGON (((-78.47812 1.18712, -78.47831 1...\n\n\n1\nhttps://simplemaps.com\nECC\nCARCHI\nPOLYGON ((-78.44211 0.87194, -78.44714 0.87437...\n\n\n2\nhttps://simplemaps.com\nECU\nSUCUMBIOS\nPOLYGON ((-77.81408 0.34566, -77.79186 0.37099...\n\n\n3\nhttps://simplemaps.com\nECD\nORELLANA\nPOLYGON ((-77.29941 -0.05855, -77.28401 -0.047...\n\n\n4\nhttps://simplemaps.com\nECY\nPASTAZA\nPOLYGON ((-77.05165 -1.01038, -77.07198 -1.033..."
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#dataset-etl-process",
    "href": "posts/MapEcuador/folium_timeline.html#dataset-etl-process",
    "title": "Time Map",
    "section": "Dataset ETL Process",
    "text": "Dataset ETL Process\n\ndf = pd.read_csv(\"presidentes_votacion_cantonal_formato_angosto.csv\")\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 77462 entries, 0 to 77461\nData columns (total 9 columns):\n #   Column            Non-Null Count  Dtype \n---  ------            --------------  ----- \n 0   ANIO              77462 non-null  int64 \n 1   VUELTA            77462 non-null  int64 \n 2   PROVINCIA_CODIGO  77462 non-null  object\n 3   PROVINCIA_NOMBRE  77462 non-null  object\n 4   CANTON_CODIGO     77462 non-null  object\n 5   CANTON_NOMBRE     77462 non-null  object\n 6   CANDIDATO_NOMBRE  77462 non-null  object\n 7   AGRUPACION        77462 non-null  object\n 8   VOTOS             77462 non-null  int64 \ndtypes: int64(3), object(6)\nmemory usage: 5.3+ MB\n\n\n\n# agrupacion para obtener valos por provincia\ndf_gr = df.groupby([\"ANIO\", \"VUELTA\", \"PROVINCIA_NOMBRE\",\n        \"CANDIDATO_NOMBRE\",\"PROVINCIA_CODIGO\"])[\"VOTOS\"].sum().reset_index()\n# solo datos de Ecuador continental \ndf_gr = df_gr[~df_gr[\"PROVINCIA_NOMBRE\"].isin(['EUROPA, ASIA, '\n'OCEANIA', 'NORTE-AMERICA', 'LATAM, CARIBE, AFRICA'])]\n# agrupacion por voto mayoritario en provinica\ndf_max = df_gr.loc[\n    df_gr.groupby(['PROVINCIA_NOMBRE','ANIO','VUELTA'])['VOTOS'].idxmax()\n]"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#working-with-the-.json-file",
    "href": "posts/MapEcuador/folium_timeline.html#working-with-the-.json-file",
    "title": "Time Map",
    "section": "Working with the .json File",
    "text": "Working with the .json File\n\n# Load Ecuador's GeoJSON data\nwith open(\"ecuador_provincias.json\", \"r\", encoding=\"utf-8\") as f:\n    geo_json_data = json.load(f)\ndf_max.PROVINCIA_NOMBRE.unique()\n\narray(['AZUAY', 'BOLIVAR', 'CANAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI', 'EL ORO', 'ESMERALDAS', 'GALAPAGOS',\n       'GUAYAS', 'IMBABURA', 'LOJA', 'LOS RIOS', 'MANABI', 'MORONA SANTIAGO', 'NAPO', 'ORELLANA', 'PASTAZA',\n       'PICHINCHA', 'SANTA ELENA', 'STO DGO TSACHILAS', 'SUCUMBIOS', 'TUNGURAHUA', 'ZAMORA CHINCHIPE'],\n      dtype=object)\n\n\n\n# Nombre de la provincias \nnombresGjson = sorted([x['properties'][\"name\"].upper() for x in geo_json_data['features']])\n# nombres a cambiar CAÑAR ,'SANTO DOMINGO DE LOS TSÁCHILAS' cambio en el dataset\ndf_max[\"PROVINCIA_NOMBRE\"] = df_max[\"PROVINCIA_NOMBRE\"].replace({'CANAR':'CAÑAR',\n                        'STO DGO TSACHILAS':'SANTO DOMINGO DE LOS TSÁCHILAS'})\ndf_max[\"PROVINCIA_NOMBRE\"].unique()\n\narray(['AZUAY', 'BOLIVAR', 'CAÑAR', 'CARCHI', 'CHIMBORAZO', 'COTOPAXI', 'EL ORO', 'ESMERALDAS', 'GALAPAGOS',\n       'GUAYAS', 'IMBABURA', 'LOJA', 'LOS RIOS', 'MANABI', 'MORONA SANTIAGO', 'NAPO', 'ORELLANA', 'PASTAZA',\n       'PICHINCHA', 'SANTA ELENA', 'SANTO DOMINGO DE LOS TSÁCHILAS', 'SUCUMBIOS', 'TUNGURAHUA',\n       'ZAMORA CHINCHIPE'], dtype=object)"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#map-style",
    "href": "posts/MapEcuador/folium_timeline.html#map-style",
    "title": "Time Map",
    "section": "Map Style",
    "text": "Map Style\n\n# COLORES POR CANDIDATO\nmapa_colores ={'ALVARO NOBOA':\"#980BEF\", 'JACOBO BUCARAM':\"#1070B9\", 'LUCIO GUTIERREZ':\"#E01212\",\n       'RODRIGO BORJA':\"#FEB00A\", 'XAVIER NEIRA':\"#F6FE69\",'RAFAEL CORREA':\"#07F93F\",\n       'LENIN MORENO':\"#07F93F\",'YAKU PEREZ':\"#F9D107\",'GUILLERMO LASSO':\"#1070B9\",\n         'LUISA GONZALEZ':\"#34FFF8\",'DANIEL NOBOA':\"#980BEF\", 'NULOS':\"#FFFFFF\",\n       'FERNANDO VILLAVICENCIO':\"#96B0FF\",'XAVIER HERVAS':\"#F9D107\", \n       'ANDRES ARAUZ':\"#07F93F\"\n       }\n# aplicar color al dataset\ndf_max['COLOR'] = df_max['CANDIDATO_NOMBRE'].apply(lambda x:mapa_colores.get(x))\ndf_max.head()\n\n\n\n\n\n\n\n\nANIO\nVUELTA\nPROVINCIA_NOMBRE\nCANDIDATO_NOMBRE\nPROVINCIA_CODIGO\nVOTOS\nCOLOR\n\n\n\n\n10\n2002\n1\nAZUAY\nRODRIGO BORJA\nEC01\n157246\n#FEB00A\n\n\n290\n2002\n2\nAZUAY\nLUCIO GUTIERREZ\nEC01\n371564\n#E01212\n\n\n397\n2006\n1\nAZUAY\nRAFAEL CORREA\nEC01\n166524\n#07F93F\n\n\n765\n2006\n2\nAZUAY\nRAFAEL CORREA\nEC01\n429830\n#07F93F\n\n\n879\n2009\n1\nAZUAY\nRAFAEL CORREA\nEC01\n418082\n#07F93F\n\n\n\n\n\n\n\n\ndef generar_start_end(row, col_anio='ANIO', col_vuelta='VUELTA'):\n    \"\"\"\n    Devuelve start y end como timestamps (ms) según:\n    - Vuelta 1: del 1 de enero al 1 de julio\n    - Vuelta 2: del 2 de julio al 31 diciembre\n    \"\"\"\n    anio = int(row[col_anio])\n    vuelta = int(row[col_vuelta])\n\n    if vuelta == 1:\n        start = pd.Timestamp(f\"{anio}-01-01 00:00:00\")\n        end   = pd.Timestamp(f\"{anio}-07-01 00:00:00\")\n    else:  # vuelta 2\n        start = pd.Timestamp(f\"{anio}-07-02 00:00:00\")\n        end   = pd.Timestamp(f\"{anio}-12-31 23:59:59\")\n\n    # convertir a timestamp en milisegundos\n    return {\n        'start': float(start.value // 10**6),\n        'end':   float(end.value   // 10**6)\n    }\n\n\ndf_max['start_end'] = df_max.apply(lambda x :\ngenerar_start_end(x, col_anio='ANIO', col_vuelta='VUELTA'),\n    axis=1\n)\n\n\ndf_merged = df_max.merge(df_ecu[['name', 'geometry']], \n                         left_on='PROVINCIA_NOMBRE', \n                         right_on='name', \n                         how='inner')\n# Convertir en GeoDataFrame\ngdf_final = gpd.GeoDataFrame(df_merged, geometry='geometry')"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#feature-generation-for-the-timeline",
    "href": "posts/MapEcuador/folium_timeline.html#feature-generation-for-the-timeline",
    "title": "Time Map",
    "section": "Feature Generation for the Timeline",
    "text": "Feature Generation for the Timeline\n\n\nfeatures = []\n\nfor _, row in gdf_final.iterrows():\n\n    start_ts = int(row['start_end']['start']) // 1000  # segundos UNIX\n\n    start_date = pd.to_datetime(start_ts, unit='s').strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n    feature = {\n        \"type\": \"Feature\",\n        \"geometry\": row[\"geometry\"].__geo_interface__,\n        \"properties\": {\n            \"time\": start_date,\n            \"style\": {\n                \"color\": \"black\",\n                \"weight\": 1,\n                \"opacity\": 1,\n                \"fillColor\": row[\"COLOR\"],\n                \"fillOpacity\": 0.8\n            },\n            \"tooltip\": f\"Provincia: {row['PROVINCIA_NOMBRE']} - {row['CANDIDATO_NOMBRE']}\",\n            \"popup\": (\n                f\"&lt;b&gt;Provincia:&lt;/b&gt; {row['PROVINCIA_NOMBRE']}&lt;br&gt;\"\n                f\"&lt;b&gt;Candidato:&lt;/b&gt; {row['CANDIDATO_NOMBRE']}&lt;br&gt;\"\n                f\"&lt;b&gt;Votos:&lt;/b&gt; {row['VOTOS']}&lt;br&gt;\"\n                f\"&lt;b&gt;Año:&lt;/b&gt; {row['ANIO']} - Vuelta {row['VUELTA']}\"\n            )\n        }\n    }\n    features.append(feature)\n\n\nBase Map\n\nm = folium.Map(\n    location=[-0.19899731681836336, -78.4428000494774],\n    tiles=\"Cartodb dark_matter\", ## estilo del fondo mapa\n    zoom_start=6\n)\n\n\n\nAdding a Temporal Layer\n\nts = TimestampedGeoJson(\n    {\n        \"type\": \"FeatureCollection\",\n        \"features\": features,\n    },\n    period=\"P1Y\",\n    duration=\"P1Y\",\n    add_last_point=True,\n    auto_play=False,\n    loop=False\n).add_to(m)"
  },
  {
    "objectID": "posts/MapEcuador/folium_timeline.html#legend-candidate-and-color-and-final-visualization",
    "href": "posts/MapEcuador/folium_timeline.html#legend-candidate-and-color-and-final-visualization",
    "title": "Time Map",
    "section": "Legend (Candidate and Color) and Final Visualization",
    "text": "Legend (Candidate and Color) and Final Visualization\n\nitems_html = \"\"\nfor candidato, color in mapa_colores.items():\n    items_html += f'''\n    &nbsp; &lt;i class=\"fa fa-square\" style=\"color:{color};\"&gt;&lt;/i&gt;\n    &nbsp; {candidato}&lt;br&gt;'''\n\nlegend_html = f\"\"\"\n{{% macro html(this, kwargs) %}}\n&lt;div style=\"\n     position: fixed;\n     bottom: 50px; left: 50px;\n     width: 250px;\n     border:2px solid grey;\n     z-index:9999;\n     font-size:14px;\n     background-color:white;\n     opacity: 0.9;\n     padding: 10px;\n     border-radius: 5px;\"&gt;\n     &lt;b&gt;🗳️ Candidato ganador&lt;/b&gt;&lt;br&gt;\n     {items_html}\n&lt;/div&gt;\n{{% endmacro %}}\n\"\"\"\n\nlegend = branca.element.MacroElement()\nlegend._template = branca.element.Template(legend_html)\nm.get_root().add_child(legend)\n\nm.save(\"VotEcuador_Timeline_Legend.html\")\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/pastel/circularPacking.html",
    "href": "posts/pastel/circularPacking.html",
    "title": "Gráficos de Pastel",
    "section": "",
    "text": "Representan proporciones de un todo: cada sector equivale a una fracción de 100%. Se basan en la lectura de ángulos y áreas, lo que es difícil para la percepción humana. Se usan principalmente para mostrar porcentajes simples con pocas categorías. Son visualmente reconocibles y llamativos como tipo de gráfico estándar."
  },
  {
    "objectID": "posts/pastel/circularPacking.html#cuándo-usar",
    "href": "posts/pastel/circularPacking.html#cuándo-usar",
    "title": "Gráficos de Pastel",
    "section": "Cuándo usar",
    "text": "Cuándo usar\n\nCuando se tienen muy pocas categorías (idealmente entre 2 y 4).\n\nPara mostrar de manera simple cómo una parte se compara con el todo.\n\nEn situaciones donde el público está acostumbrado a este tipo de gráfico."
  },
  {
    "objectID": "posts/pastel/circularPacking.html#errores-comunes",
    "href": "posts/pastel/circularPacking.html#errores-comunes",
    "title": "Gráficos de Pastel",
    "section": "Errores comunes",
    "text": "Errores comunes\n\nIncluir demasiadas categorías, más de 5–6 sectores.\n\nComparar múltiples gráficos de pastel, lo cual dificulta ver patrones o cambios.\n\nUsar efectos en 3D que distorsionan la percepción.\n\nColocar la leyenda separada, obligando a saltar la vista.\n\nUtilizar sectores explotados (exploded pie) que rompen la proporción.\n\nMostrar porcentajes que no suman 100%.\n\nEmplear colores demasiado similares que impiden distinguir categorías."
  },
  {
    "objectID": "posts/pastel/circularPacking.html#alternativas",
    "href": "posts/pastel/circularPacking.html#alternativas",
    "title": "Gráficos de Pastel",
    "section": "Alternativas",
    "text": "Alternativas\n\nGráfico de barras: más preciso y fácil de comparar valores.\n\nLollipop chart: variante clara y elegante para varias categorías.\n\nTreemap: adecuado para mostrar la composición de un todo con muchas partes."
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html",
    "href": "posts/post-with-code/stravaPlotOSMNX.html",
    "title": "Strava Route Plot OSMNX",
    "section": "",
    "text": "Strava Route Plot using OSMnx involves visualizing and analyzing running or cycling routes recorded with the Strava app on maps generated with the OSMnx library. OSMnx is a Python package that allows users to download, model, and visualize street networks from OpenStreetMap’s data.\nimport osmnx as ox\nimport pandas as pd\nimport gpxpy\nimport gpxpy.gpx\nimport matplotlib.pyplot as plt\nimport polyline"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#read-route",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#read-route",
    "title": "Strava Route Plot OSMNX",
    "section": "1. Read Route",
    "text": "1. Read Route\n\npath = \"Princesa_Toa_.gpx\"\nwith open(path, 'r') as gpx_file:\n    gpx = gpxpy.parse(gpx_file)\n    \n# extract in gpx file latitude, longitude  and elevation\nroute_info = [{'latitude': point.latitude,'longitude': point.longitude,'elevation': point.elevation} \n              for track   in gpx.tracks  \n              for segment in track.segments \n              for point   in segment.points ]\n# route_df Dataframe\nroute_df = pd.DataFrame(route_info)\nroute_df.head()\n\n\n\n\n\n\n\n\nlatitude\nlongitude\nelevation\n\n\n\n\n0\n-0.216083\n-78.436892\n2388.8\n\n\n1\n-0.216085\n-78.436895\n2388.8\n\n\n2\n-0.216141\n-78.436849\n2388.9\n\n\n3\n-0.216161\n-78.436832\n2388.9\n\n\n4\n-0.216211\n-78.436803\n2389.0"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#center-point-for-graph-in-ox",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#center-point-for-graph-in-ox",
    "title": "Strava Route Plot OSMNX",
    "section": "2. Center point for Graph in ox",
    "text": "2. Center point for Graph in ox\nLink osmnx graph_from_point fuction https://osmnx.readthedocs.io/en/stable/osmnx.html?highlight=graph_from_point#osmnx.graph.graph_from_point\n\n# center point to extract graph latitude , longitude\ncenter_point = (-0.26428048222240524, -78.4202862684383)\nG = ox.graph_from_point(center_point, dist=12000, retain_all=True, simplify = False, network_type='all')\n#bike all"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#plot-route",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#plot-route",
    "title": "Strava Route Plot OSMNX",
    "section": "3. Plot Route",
    "text": "3. Plot Route\n\nfig, ax = ox.plot_graph(G, node_size=0,\n                        figsize        = (11, 16), \n                        dpi            = 300,\n                        save           = False,\n                        bgcolor        = \"#FFFFFF\",\n                        edge_color     = \"#253951\",\n                        edge_alpha     = 0.2 ,\n                        show           = False)\n## Plot  activity in graph \nplt.plot( route_df['longitude'] , route_df['latitude'] ,\n         color     = \"#E64E25\" , \n         linewidth = 2.0)\n## Plot  activity in graph \nplt.show()\nfig.tight_layout(pad=0)\n## path name to save\npath_save = path.split(\".\")[0] + \".png\"\n# fig.savefig( path_save, dpi=300, format=\"png\", bbox_inches='tight',\n#             facecolor=fig.get_facecolor(), transparent=False)\n\n\n\n\n\n\n\n\n\n# save figure\nfig.savefig('activity.png')"
  },
  {
    "objectID": "posts/post-with-code/stravaPlotOSMNX.html#plot-elevation",
    "href": "posts/post-with-code/stravaPlotOSMNX.html#plot-elevation",
    "title": "Strava Route Plot OSMNX",
    "section": "4. Plot Elevation",
    "text": "4. Plot Elevation\n\nelevation = route_df.elevation\nx_plot    = range(len(elevation))\nmin_elev  = min(elevation) - 25\n\n\n# Set the figure size\nfig, ax = plt.subplots(figsize=(11, 2))\n# Area plot\nax.fill_between(x_plot, elevation, color=\"#E64E25\")\n# Set the minimum and maximum values for the y-axis\nax.set_ylim(min_elev, 4000)\nplt.axis('off')\n# Save the figure\npath_save = path.split(\".\")[0] +\"_elevation\" \".png\"\nplt.savefig(path_save , transparent=True, bbox_inches='tight', pad_inches=0 )\n# Display the plot\nplt.show()\n\n\n\n\n\n\n\n\n\nfig.savefig('perfil.png')"
  },
  {
    "objectID": "posts/Puntos/Puntos.html",
    "href": "posts/Puntos/Puntos.html",
    "title": "Diagramas de puntos",
    "section": "",
    "text": "Los diagramas de puntos son diagramas de dispersión con un eje categórico y un eje continuo. Permiten mostrar cambios entre dos o más puntos en el tiempo o entre dos o más condiciones. En comparación con un gráfico de barras , los diagramas de puntos son menos confusos y facilitan la comparación entre condiciones."
  },
  {
    "objectID": "posts/Puntos/Puntos.html#cambiar-titulo-eliminar-axis-nombre",
    "href": "posts/Puntos/Puntos.html#cambiar-titulo-eliminar-axis-nombre",
    "title": "Diagramas de puntos",
    "section": "Cambiar titulo eliminar axis (Nombre)",
    "text": "Cambiar titulo eliminar axis (Nombre)\n\nimport numpy as np\nimport pandas as pd\nimport plotly.express as px\nimport plotly.io as pio\n\npio.renderers.default = \"notebook\"\n\n# Agrupar por año y contar artículos\ndf_year = df.groupby(\"AÑO\").size().reset_index(name=\"NUM_ARTICULOS\")\n\n# Etiqueta abreviada (12k, 800, etc.)\ndef abrevia(n):\n    return f\"{n/1_000:.0f}k\" if n &gt;= 1000 else str(n)\ndf_year[\"LABEL\"] = df_year[\"NUM_ARTICULOS\"].map(abrevia)\n\n# Gráfico base\nfig = px.scatter(\n    df_year,\n    x=\"AÑO\",\n    y=\"NUM_ARTICULOS\",\n    size=\"NUM_ARTICULOS\",\n    text=\"LABEL\",\n    title='&lt;span style=\"color:#43B099;\"&gt;Tendencias del número de artículos académicos en el Ecuador por año,&lt;br&gt;&lt;/span&gt;'\n'&lt;span style=\"color:red;\"&gt;siendo el año 2020 un punto de partida&lt;/span&gt;'\n)\n\n# Colorear/contornear por punto (rojo solo en 2020)\nx_vals = df_year[\"AÑO\"].to_list()\nis_2020 = [x == 2020 for x in x_vals]\n\ncolors = [\"red\" if f else \"#43B099\" for f in is_2020]\nline_widths = [2 if f else 0 for f in is_2020]\n\nfig.data[0].marker.color = colors\nfig.data[0].marker.line.color = \"red\"\nfig.data[0].marker.line.width = line_widths\n\n# Mostrar todos los ticks del eje X\nfig.update_xaxes(\n    tickmode=\"array\",\n    tickvals=sorted(df_year[\"AÑO\"].unique()),\n    ticktext=[str(y) for y in sorted(df_year[\"AÑO\"].unique())]\n)\n\n# Ocultar eje Y y títulos\nfig.update_traces(textposition=\"top center\")\nfig.update_layout(\n    xaxis_title=None,  # quitar título eje X\n    yaxis_title=None,  # quitar título eje Y\n    yaxis=dict(showticklabels=False, showline=False, showgrid=False, zeroline=False),\n    plot_bgcolor=\"white\",\n    margin=dict(l=10, r=10, t=60, b=40)\n)\n\n# Línea vertical opcional en 2020\nfig.add_vline(x=2020, line_width=1, line_dash=\"dot\", line_color=\"red\")\n\nfig.show()"
  },
  {
    "objectID": "posts/slopegraph/slopegraph.html",
    "href": "posts/slopegraph/slopegraph.html",
    "title": "Heatmap",
    "section": "",
    "text": "Gráfico (Gráfica de pendiente) propuesto por Edward Tufte que muestra cómo cambian varias entidades entre dos puntos de comparación (por ejemplo, dos años, dos categorías o dos valores). Cada entidad se representa con una línea que conecta su valor inicial y su valor final."
  },
  {
    "objectID": "posts/slopegraph/slopegraph.html#cuándo-utilizar-un-slopegraph",
    "href": "posts/slopegraph/slopegraph.html#cuándo-utilizar-un-slopegraph",
    "title": "Heatmap",
    "section": "Cuándo utilizar un slopegraph",
    "text": "Cuándo utilizar un slopegraph\n\nComparaciones “antes y después”\nCambios en el ranking o jerarquía\nMagnitud relativa del cambio\nPosicionamiento relativo entre dos variables\nVariaciones con múltiples dimensiones\nIdentificación de desviaciones en la tendencia"
  },
  {
    "objectID": "posts/slopegraph/slopegraph.html#errores-comunes",
    "href": "posts/slopegraph/slopegraph.html#errores-comunes",
    "title": "Heatmap",
    "section": "Errores comunes",
    "text": "Errores comunes\n\nComparaciones sin relación lógica\nNo es adecuado cuando los dos puntos comparados no tienen un vínculo significativo, ya que se pueden generar correlaciones engañosas.\nAusencia de tendencia clara\nSi los valores no muestran un patrón evidente, el gráfico se llena de líneas cruzadas y pierde legibilidad.\nCuando la serie completa es relevante\nSi lo importante son las fluctuaciones intermedias, conviene usar gráficos de líneas o de áreas en lugar de un slopegraph."
  },
  {
    "objectID": "posts/slopegraph/slopegraph.html#ventajas",
    "href": "posts/slopegraph/slopegraph.html#ventajas",
    "title": "Heatmap",
    "section": "Ventajas",
    "text": "Ventajas\n\nClaridad y minimalismo: elimina elementos innecesarios y se centra en la comparación esencial.\n\nFlexibilidad en el eje Y: no requiere iniciar en cero, lo que facilita hacer “zoom” en los datos.\n\nFácil interpretación: incluso por públicos sin formación en visualización de datos.\n\nLimitar el número de entidades para evitar un gráfico saturado.\n\nResaltar solo las entidades clave y dejar las demás en gris.\n\nUtilizar paletas divergentes (verde para aumentos, rojo para descensos).\n\nAgrupar categorías mediante un color común.\n\nEtiquetas claras en ambos extremos: incluir tanto el nombre como el valor en los dos lados del gráfico, asegurando buena legibilidad."
  },
  {
    "objectID": "posts/TreeMap/treeMap.html",
    "href": "posts/TreeMap/treeMap.html",
    "title": "Mapa de árbol",
    "section": "",
    "text": "Un Treemap (mapa de árbol) es una visualización compuesta de rectángulos anidados.\nCada rectángulo representa una categoría dentro de una dimensión seleccionada y está ordenado jerárquicamente en un árbol.\nEl área del rectángulo es proporcional al valor que representa.\nEsta técnica fue desarrollada por Ben Shneiderman (Universidad de Maryland) con el objetivo de aprovechar al máximo espacios reducidos en gráficos jerárquicos."
  },
  {
    "objectID": "posts/TreeMap/treeMap.html#para-qué-sirve",
    "href": "posts/TreeMap/treeMap.html#para-qué-sirve",
    "title": "Mapa de árbol",
    "section": "¿Para qué sirve?",
    "text": "¿Para qué sirve?\nUn Treemap es especialmente útil para mostrar relaciones parte-todo:\n\nPermite ver rápidamente qué categorías tienen mayor peso relativo.\n\nFacilita la comparación de patrones y cantidades en un espacio limitado.\n\nPuede mostrar hasta 3 niveles de jerarquía de manera efectiva en estático.\n\nUso eficiente del espacio → ideal para grandes volúmenes de datos.\n\nPermite mostrar simultáneamente jerarquía y proporciones.\n\nCon interactividad se pueden explorar fácilmente múltiples niveles."
  },
  {
    "objectID": "posts/TreeMap/treeMap.html#errores-comunes",
    "href": "posts/TreeMap/treeMap.html#errores-comunes",
    "title": "Mapa de árbol",
    "section": "Errores comunes",
    "text": "Errores comunes\nUn buen Treemap debe tener:\n- Valores numéricos claros.\n- Jerarquía bien definida.\n- No más de 3–4 rectángulos etiquetados.\n- Nivel jerárquico superior bien identificado.\n- Solo valores positivos.\nUn mal Treemap ocurre cuando:\n- Tiene demasiadas categorías → se ve abarrotado.\n- Los rectángulos son muy similares en tamaño → difícil de comparar.\n- Usa la misma paleta de color para distintas categorías.\nAlternativa recomendada:\nCuando el Treemap se vuelve confuso, es mejor usar un gráfico de barras, ya que permite comparar fácilmente de mayor a menor."
  },
  {
    "objectID": "posts/TreeMap/treeMap.html#variaciones",
    "href": "posts/TreeMap/treeMap.html#variaciones",
    "title": "Mapa de árbol",
    "section": "Variaciones",
    "text": "Variaciones\n\nEstáticos → adecuados para 1–2 niveles jerárquicos.\n\nInteractivos → recomendados cuando hay 3 o más niveles.\n\nPermiten hacer zoom en un grupo y explorar subcategorías.\n\nClic en el título para volver al nivel superior."
  },
  {
    "objectID": "posts/TreeMap/treeMap.html#realize-el-mismo-gráfico-para-la-base-de-articulos-cientificos-ecuador",
    "href": "posts/TreeMap/treeMap.html#realize-el-mismo-gráfico-para-la-base-de-articulos-cientificos-ecuador",
    "title": "Mapa de árbol",
    "section": "Realize el mismo gráfico para la base de articulos cientificos Ecuador",
    "text": "Realize el mismo gráfico para la base de articulos cientificos Ecuador"
  },
  {
    "objectID": "posts/violin/violin.html",
    "href": "posts/violin/violin.html",
    "title": "Violin Plot",
    "section": "",
    "text": "Un gráfico de violín es una técnica de visualización de datos que combina elementos de un boxplot (o gráfico de caja y bigotes) con la representación de la densidad de probabilidad de los datos.\nMientras que el boxplot resume una distribución en cuartiles, mediana y valores extremos, el gráfico de violín añade la forma de la distribución mediante un estimador de densidad kernel, lo que permite observar si los datos presentan asimetrías, picos múltiples (modas) o distribuciones inusuales."
  },
  {
    "objectID": "posts/violin/violin.html#descripción",
    "href": "posts/violin/violin.html#descripción",
    "title": "Violin Plot",
    "section": "0.1 Descripción",
    "text": "0.1 Descripción\n\nLa anchura del “violín” en cada altura refleja la densidad de probabilidad de los datos en ese rango de valores.\n\nIncluye un boxplot interno que marca la mediana y los cuartiles.\n\nPuede mostrar también todos los puntos de datos individuales, si la muestra no es demasiado grande.\n\nAl colocar varios violines lado a lado, es posible comparar cómo cambia la distribución entre grupos o categorías."
  },
  {
    "objectID": "posts/violin/violin.html#utilidad",
    "href": "posts/violin/violin.html#utilidad",
    "title": "Violin Plot",
    "section": "0.2 Utilidad",
    "text": "0.2 Utilidad\n\nPermite visualizar la forma completa de la distribución en lugar de limitarse a medidas de resumen.\n\nFacilita la detección de asimetrías, concentraciones de datos y distribuciones multimodales.\n\nEs especialmente útil en grandes conjuntos de datos, donde graficar todas las observaciones es inviable.\n\nCombina la capacidad de síntesis del boxplot con la riqueza visual de un histograma suavizado."
  },
  {
    "objectID": "posts/violin/violin.html#errores-comunes",
    "href": "posts/violin/violin.html#errores-comunes",
    "title": "Violin Plot",
    "section": "0.3 Errores Comunes",
    "text": "0.3 Errores Comunes\n\nPocos grupos: si solo se comparan dos o tres categorías, puede ser más adecuado un gráfico tipo ridgeline.\n\nTamaños de muestra muy diferentes: conviene señalarlo explícitamente para evitar malas interpretaciones.\n\nNo ordenar los violines por la mediana u otro criterio relevante puede dificultar la comparación entre categorías."
  }
]